// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GameMsg.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "GameMsg.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace proto {

void protobuf_ShutdownFile_GameMsg_2eproto() {
  delete User_t::default_instance_;
  delete Room_t::default_instance_;
  delete Player_t::default_instance_;
  delete GameCommand_t::default_instance_;
  delete Login_req::default_instance_;
  delete Login_ack::default_instance_;
  delete ListRoom_req::default_instance_;
  delete ListRoom_ack::default_instance_;
  delete CreateRoom_req::default_instance_;
  delete CreateRoom_ack::default_instance_;
  delete JoinRoom_req::default_instance_;
  delete JoinRoom_ack::default_instance_;
  delete PlayerList_ntf::default_instance_;
  delete EnterGame_ntf::default_instance_;
  delete EnterGameOk_req::default_instance_;
  delete StartRace_ntf::default_instance_;
  delete LogicFrame_ntf::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_GameMsg_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_GameMsg_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  User_t::default_instance_ = new User_t();
  Room_t::default_instance_ = new Room_t();
  Player_t::default_instance_ = new Player_t();
  GameCommand_t::default_instance_ = new GameCommand_t();
  Login_req::default_instance_ = new Login_req();
  Login_ack::default_instance_ = new Login_ack();
  ListRoom_req::default_instance_ = new ListRoom_req();
  ListRoom_ack::default_instance_ = new ListRoom_ack();
  CreateRoom_req::default_instance_ = new CreateRoom_req();
  CreateRoom_ack::default_instance_ = new CreateRoom_ack();
  JoinRoom_req::default_instance_ = new JoinRoom_req();
  JoinRoom_ack::default_instance_ = new JoinRoom_ack();
  PlayerList_ntf::default_instance_ = new PlayerList_ntf();
  EnterGame_ntf::default_instance_ = new EnterGame_ntf();
  EnterGameOk_req::default_instance_ = new EnterGameOk_req();
  StartRace_ntf::default_instance_ = new StartRace_ntf();
  LogicFrame_ntf::default_instance_ = new LogicFrame_ntf();
  User_t::default_instance_->InitAsDefaultInstance();
  Room_t::default_instance_->InitAsDefaultInstance();
  Player_t::default_instance_->InitAsDefaultInstance();
  GameCommand_t::default_instance_->InitAsDefaultInstance();
  Login_req::default_instance_->InitAsDefaultInstance();
  Login_ack::default_instance_->InitAsDefaultInstance();
  ListRoom_req::default_instance_->InitAsDefaultInstance();
  ListRoom_ack::default_instance_->InitAsDefaultInstance();
  CreateRoom_req::default_instance_->InitAsDefaultInstance();
  CreateRoom_ack::default_instance_->InitAsDefaultInstance();
  JoinRoom_req::default_instance_->InitAsDefaultInstance();
  JoinRoom_ack::default_instance_->InitAsDefaultInstance();
  PlayerList_ntf::default_instance_->InitAsDefaultInstance();
  EnterGame_ntf::default_instance_->InitAsDefaultInstance();
  EnterGameOk_req::default_instance_->InitAsDefaultInstance();
  StartRace_ntf::default_instance_->InitAsDefaultInstance();
  LogicFrame_ntf::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_GameMsg_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_GameMsg_2eproto_once_);
void protobuf_AddDesc_GameMsg_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_GameMsg_2eproto_once_,
                 &protobuf_AddDesc_GameMsg_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_GameMsg_2eproto {
  StaticDescriptorInitializer_GameMsg_2eproto() {
    protobuf_AddDesc_GameMsg_2eproto();
  }
} static_descriptor_initializer_GameMsg_2eproto_;
#endif
bool ErrorCode_t_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

bool GameMsgId_t_IsValid(int value) {
  switch(value) {
    case 135:
    case 136:
    case 137:
    case 138:
    case 139:
    case 140:
    case 141:
    case 142:
    case 143:
    case 144:
    case 145:
    case 146:
    case 147:
    case 148:
      return true;
    default:
      return false;
  }
}

bool GameCommandType_t_IsValid(int value) {
  switch(value) {
    case 1:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int User_t::kUseridFieldNumber;
const int User_t::kNicknameFieldNumber;
#endif  // !_MSC_VER

User_t::User_t()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void User_t::InitAsDefaultInstance() {
}

User_t::User_t(const User_t& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void User_t::SharedCtor() {
  _cached_size_ = 0;
  userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

User_t::~User_t() {
  SharedDtor();
}

void User_t::SharedDtor() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    delete userid_;
  }
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    delete nickname_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void User_t::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const User_t& User_t::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GameMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GameMsg_2eproto();
#endif
  return *default_instance_;
}

User_t* User_t::default_instance_ = NULL;

User_t* User_t::New() const {
  return new User_t;
}

void User_t::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_userid()) {
      if (userid_ != &::google::protobuf::internal::kEmptyString) {
        userid_->clear();
      }
    }
    if (has_nickname()) {
      if (nickname_ != &::google::protobuf::internal::kEmptyString) {
        nickname_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool User_t::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string userid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_userid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_nickname;
        break;
      }

      // optional string nickname = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_nickname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_nickname()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void User_t::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string userid = 1;
  if (has_userid()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->userid(), output);
  }

  // optional string nickname = 2;
  if (has_nickname()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->nickname(), output);
  }

}

int User_t::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string userid = 1;
    if (has_userid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->userid());
    }

    // optional string nickname = 2;
    if (has_nickname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->nickname());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void User_t::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const User_t*>(&from));
}

void User_t::MergeFrom(const User_t& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_userid()) {
      set_userid(from.userid());
    }
    if (from.has_nickname()) {
      set_nickname(from.nickname());
    }
  }
}

void User_t::CopyFrom(const User_t& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool User_t::IsInitialized() const {

  return true;
}

void User_t::Swap(User_t* other) {
  if (other != this) {
    std::swap(userid_, other->userid_);
    std::swap(nickname_, other->nickname_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string User_t::GetTypeName() const {
  return "proto.User_t";
}


// ===================================================================

#ifndef _MSC_VER
const int Room_t::kRoomNoFieldNumber;
const int Room_t::kDespFieldNumber;
#endif  // !_MSC_VER

Room_t::Room_t()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Room_t::InitAsDefaultInstance() {
}

Room_t::Room_t(const Room_t& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Room_t::SharedCtor() {
  _cached_size_ = 0;
  room_no_ = 0;
  desp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Room_t::~Room_t() {
  SharedDtor();
}

void Room_t::SharedDtor() {
  if (desp_ != &::google::protobuf::internal::kEmptyString) {
    delete desp_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Room_t::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Room_t& Room_t::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GameMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GameMsg_2eproto();
#endif
  return *default_instance_;
}

Room_t* Room_t::default_instance_ = NULL;

Room_t* Room_t::New() const {
  return new Room_t;
}

void Room_t::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    room_no_ = 0;
    if (has_desp()) {
      if (desp_ != &::google::protobuf::internal::kEmptyString) {
        desp_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Room_t::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 room_no = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &room_no_)));
          set_has_room_no();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_desp;
        break;
      }

      // optional string desp = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_desp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_desp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Room_t::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 room_no = 1;
  if (has_room_no()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->room_no(), output);
  }

  // optional string desp = 2;
  if (has_desp()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->desp(), output);
  }

}

int Room_t::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 room_no = 1;
    if (has_room_no()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->room_no());
    }

    // optional string desp = 2;
    if (has_desp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->desp());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Room_t::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Room_t*>(&from));
}

void Room_t::MergeFrom(const Room_t& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_room_no()) {
      set_room_no(from.room_no());
    }
    if (from.has_desp()) {
      set_desp(from.desp());
    }
  }
}

void Room_t::CopyFrom(const Room_t& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Room_t::IsInitialized() const {

  return true;
}

void Room_t::Swap(Room_t* other) {
  if (other != this) {
    std::swap(room_no_, other->room_no_);
    std::swap(desp_, other->desp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Room_t::GetTypeName() const {
  return "proto.Room_t";
}


// ===================================================================

#ifndef _MSC_VER
const int Player_t::kPlayeridFieldNumber;
const int Player_t::kUseridFieldNumber;
const int Player_t::kCarNameFieldNumber;
const int Player_t::kIsFreeFieldNumber;
const int Player_t::kIsOwnedFieldNumber;
const int Player_t::kStageFieldNumber;
const int Player_t::kDecalFieldNumber;
const int Player_t::kDecalColorFieldNumber;
const int Player_t::kDriverNameFieldNumber;
const int Player_t::kDriverTypeFieldNumber;
const int Player_t::kAccelFieldNumber;
const int Player_t::kSpeedFieldNumber;
const int Player_t::kHandlingFieldNumber;
const int Player_t::kToughFieldNumber;
const int Player_t::kIsGoldFieldNumber;
const int Player_t::kMinStageFieldNumber;
const int Player_t::kMaxStageFieldNumber;
const int Player_t::kPaintColorFieldNumber;
#endif  // !_MSC_VER

Player_t::Player_t()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Player_t::InitAsDefaultInstance() {
}

Player_t::Player_t(const Player_t& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Player_t::SharedCtor() {
  _cached_size_ = 0;
  playerid_ = 0;
  userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  car_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  is_free_ = 0;
  is_owned_ = 0;
  stage_ = 0;
  decal_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  decal_color_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  driver_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  driver_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  accel_ = 0;
  speed_ = 0;
  handling_ = 0;
  tough_ = 0;
  is_gold_ = 0;
  min_stage_ = 0;
  max_stage_ = 0;
  paint_color_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Player_t::~Player_t() {
  SharedDtor();
}

void Player_t::SharedDtor() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    delete userid_;
  }
  if (car_name_ != &::google::protobuf::internal::kEmptyString) {
    delete car_name_;
  }
  if (decal_ != &::google::protobuf::internal::kEmptyString) {
    delete decal_;
  }
  if (decal_color_ != &::google::protobuf::internal::kEmptyString) {
    delete decal_color_;
  }
  if (driver_name_ != &::google::protobuf::internal::kEmptyString) {
    delete driver_name_;
  }
  if (driver_type_ != &::google::protobuf::internal::kEmptyString) {
    delete driver_type_;
  }
  if (paint_color_ != &::google::protobuf::internal::kEmptyString) {
    delete paint_color_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Player_t::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Player_t& Player_t::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GameMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GameMsg_2eproto();
#endif
  return *default_instance_;
}

Player_t* Player_t::default_instance_ = NULL;

Player_t* Player_t::New() const {
  return new Player_t;
}

void Player_t::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    playerid_ = 0;
    if (has_userid()) {
      if (userid_ != &::google::protobuf::internal::kEmptyString) {
        userid_->clear();
      }
    }
    if (has_car_name()) {
      if (car_name_ != &::google::protobuf::internal::kEmptyString) {
        car_name_->clear();
      }
    }
    is_free_ = 0;
    is_owned_ = 0;
    stage_ = 0;
    if (has_decal()) {
      if (decal_ != &::google::protobuf::internal::kEmptyString) {
        decal_->clear();
      }
    }
    if (has_decal_color()) {
      if (decal_color_ != &::google::protobuf::internal::kEmptyString) {
        decal_color_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_driver_name()) {
      if (driver_name_ != &::google::protobuf::internal::kEmptyString) {
        driver_name_->clear();
      }
    }
    if (has_driver_type()) {
      if (driver_type_ != &::google::protobuf::internal::kEmptyString) {
        driver_type_->clear();
      }
    }
    accel_ = 0;
    speed_ = 0;
    handling_ = 0;
    tough_ = 0;
    is_gold_ = 0;
    min_stage_ = 0;
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    max_stage_ = 0;
    if (has_paint_color()) {
      if (paint_color_ != &::google::protobuf::internal::kEmptyString) {
        paint_color_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Player_t::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 playerid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &playerid_)));
          set_has_playerid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_userid;
        break;
      }

      // optional string userid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_userid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_userid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_car_name;
        break;
      }

      // optional string car_name = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_car_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_car_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_is_free;
        break;
      }

      // optional int32 is_free = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_free:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &is_free_)));
          set_has_is_free();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_is_owned;
        break;
      }

      // optional int32 is_owned = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_owned:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &is_owned_)));
          set_has_is_owned();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_stage;
        break;
      }

      // optional int32 stage = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_stage:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &stage_)));
          set_has_stage();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_decal;
        break;
      }

      // optional string decal = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_decal:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_decal()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_decal_color;
        break;
      }

      // optional string decal_color = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_decal_color:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_decal_color()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_driver_name;
        break;
      }

      // optional string driver_name = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_driver_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_driver_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_driver_type;
        break;
      }

      // optional string driver_type = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_driver_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_driver_type()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_accel;
        break;
      }

      // optional int32 accel = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_accel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &accel_)));
          set_has_accel();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(96)) goto parse_speed;
        break;
      }

      // optional int32 speed = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_speed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &speed_)));
          set_has_speed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(104)) goto parse_handling;
        break;
      }

      // optional int32 handling = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_handling:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &handling_)));
          set_has_handling();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(112)) goto parse_tough;
        break;
      }

      // optional int32 tough = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_tough:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &tough_)));
          set_has_tough();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(120)) goto parse_is_gold;
        break;
      }

      // optional int32 is_gold = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_gold:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &is_gold_)));
          set_has_is_gold();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(128)) goto parse_min_stage;
        break;
      }

      // optional int32 min_stage = 16;
      case 16: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_min_stage:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &min_stage_)));
          set_has_min_stage();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(136)) goto parse_max_stage;
        break;
      }

      // optional int32 max_stage = 17;
      case 17: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_max_stage:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_stage_)));
          set_has_max_stage();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(146)) goto parse_paint_color;
        break;
      }

      // optional string paint_color = 18;
      case 18: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_paint_color:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_paint_color()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Player_t::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 playerid = 1;
  if (has_playerid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->playerid(), output);
  }

  // optional string userid = 2;
  if (has_userid()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->userid(), output);
  }

  // optional string car_name = 3;
  if (has_car_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->car_name(), output);
  }

  // optional int32 is_free = 4;
  if (has_is_free()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->is_free(), output);
  }

  // optional int32 is_owned = 5;
  if (has_is_owned()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->is_owned(), output);
  }

  // optional int32 stage = 6;
  if (has_stage()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->stage(), output);
  }

  // optional string decal = 7;
  if (has_decal()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      7, this->decal(), output);
  }

  // optional string decal_color = 8;
  if (has_decal_color()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      8, this->decal_color(), output);
  }

  // optional string driver_name = 9;
  if (has_driver_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      9, this->driver_name(), output);
  }

  // optional string driver_type = 10;
  if (has_driver_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      10, this->driver_type(), output);
  }

  // optional int32 accel = 11;
  if (has_accel()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(11, this->accel(), output);
  }

  // optional int32 speed = 12;
  if (has_speed()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(12, this->speed(), output);
  }

  // optional int32 handling = 13;
  if (has_handling()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(13, this->handling(), output);
  }

  // optional int32 tough = 14;
  if (has_tough()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(14, this->tough(), output);
  }

  // optional int32 is_gold = 15;
  if (has_is_gold()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(15, this->is_gold(), output);
  }

  // optional int32 min_stage = 16;
  if (has_min_stage()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(16, this->min_stage(), output);
  }

  // optional int32 max_stage = 17;
  if (has_max_stage()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(17, this->max_stage(), output);
  }

  // optional string paint_color = 18;
  if (has_paint_color()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      18, this->paint_color(), output);
  }

}

int Player_t::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 playerid = 1;
    if (has_playerid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->playerid());
    }

    // optional string userid = 2;
    if (has_userid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->userid());
    }

    // optional string car_name = 3;
    if (has_car_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->car_name());
    }

    // optional int32 is_free = 4;
    if (has_is_free()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->is_free());
    }

    // optional int32 is_owned = 5;
    if (has_is_owned()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->is_owned());
    }

    // optional int32 stage = 6;
    if (has_stage()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->stage());
    }

    // optional string decal = 7;
    if (has_decal()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->decal());
    }

    // optional string decal_color = 8;
    if (has_decal_color()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->decal_color());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional string driver_name = 9;
    if (has_driver_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->driver_name());
    }

    // optional string driver_type = 10;
    if (has_driver_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->driver_type());
    }

    // optional int32 accel = 11;
    if (has_accel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->accel());
    }

    // optional int32 speed = 12;
    if (has_speed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->speed());
    }

    // optional int32 handling = 13;
    if (has_handling()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->handling());
    }

    // optional int32 tough = 14;
    if (has_tough()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->tough());
    }

    // optional int32 is_gold = 15;
    if (has_is_gold()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->is_gold());
    }

    // optional int32 min_stage = 16;
    if (has_min_stage()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->min_stage());
    }

  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional int32 max_stage = 17;
    if (has_max_stage()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->max_stage());
    }

    // optional string paint_color = 18;
    if (has_paint_color()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->paint_color());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Player_t::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Player_t*>(&from));
}

void Player_t::MergeFrom(const Player_t& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_playerid()) {
      set_playerid(from.playerid());
    }
    if (from.has_userid()) {
      set_userid(from.userid());
    }
    if (from.has_car_name()) {
      set_car_name(from.car_name());
    }
    if (from.has_is_free()) {
      set_is_free(from.is_free());
    }
    if (from.has_is_owned()) {
      set_is_owned(from.is_owned());
    }
    if (from.has_stage()) {
      set_stage(from.stage());
    }
    if (from.has_decal()) {
      set_decal(from.decal());
    }
    if (from.has_decal_color()) {
      set_decal_color(from.decal_color());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_driver_name()) {
      set_driver_name(from.driver_name());
    }
    if (from.has_driver_type()) {
      set_driver_type(from.driver_type());
    }
    if (from.has_accel()) {
      set_accel(from.accel());
    }
    if (from.has_speed()) {
      set_speed(from.speed());
    }
    if (from.has_handling()) {
      set_handling(from.handling());
    }
    if (from.has_tough()) {
      set_tough(from.tough());
    }
    if (from.has_is_gold()) {
      set_is_gold(from.is_gold());
    }
    if (from.has_min_stage()) {
      set_min_stage(from.min_stage());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_max_stage()) {
      set_max_stage(from.max_stage());
    }
    if (from.has_paint_color()) {
      set_paint_color(from.paint_color());
    }
  }
}

void Player_t::CopyFrom(const Player_t& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Player_t::IsInitialized() const {

  return true;
}

void Player_t::Swap(Player_t* other) {
  if (other != this) {
    std::swap(playerid_, other->playerid_);
    std::swap(userid_, other->userid_);
    std::swap(car_name_, other->car_name_);
    std::swap(is_free_, other->is_free_);
    std::swap(is_owned_, other->is_owned_);
    std::swap(stage_, other->stage_);
    std::swap(decal_, other->decal_);
    std::swap(decal_color_, other->decal_color_);
    std::swap(driver_name_, other->driver_name_);
    std::swap(driver_type_, other->driver_type_);
    std::swap(accel_, other->accel_);
    std::swap(speed_, other->speed_);
    std::swap(handling_, other->handling_);
    std::swap(tough_, other->tough_);
    std::swap(is_gold_, other->is_gold_);
    std::swap(min_stage_, other->min_stage_);
    std::swap(max_stage_, other->max_stage_);
    std::swap(paint_color_, other->paint_color_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Player_t::GetTypeName() const {
  return "proto.Player_t";
}


// ===================================================================

#ifndef _MSC_VER
const int GameCommand_t::kCommandTypeFieldNumber;
const int GameCommand_t::kPlayeridFieldNumber;
const int GameCommand_t::kIntvar1FieldNumber;
const int GameCommand_t::kIntvar2FieldNumber;
const int GameCommand_t::kIntvar3FieldNumber;
const int GameCommand_t::kStrvar1FieldNumber;
const int GameCommand_t::kStrvar2FieldNumber;
const int GameCommand_t::kStrvar3FieldNumber;
#endif  // !_MSC_VER

GameCommand_t::GameCommand_t()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GameCommand_t::InitAsDefaultInstance() {
}

GameCommand_t::GameCommand_t(const GameCommand_t& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GameCommand_t::SharedCtor() {
  _cached_size_ = 0;
  command_type_ = 0;
  playerid_ = 0;
  intvar1_ = 0;
  intvar2_ = 0;
  intvar3_ = 0;
  strvar1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  strvar2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  strvar3_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GameCommand_t::~GameCommand_t() {
  SharedDtor();
}

void GameCommand_t::SharedDtor() {
  if (strvar1_ != &::google::protobuf::internal::kEmptyString) {
    delete strvar1_;
  }
  if (strvar2_ != &::google::protobuf::internal::kEmptyString) {
    delete strvar2_;
  }
  if (strvar3_ != &::google::protobuf::internal::kEmptyString) {
    delete strvar3_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GameCommand_t::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GameCommand_t& GameCommand_t::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GameMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GameMsg_2eproto();
#endif
  return *default_instance_;
}

GameCommand_t* GameCommand_t::default_instance_ = NULL;

GameCommand_t* GameCommand_t::New() const {
  return new GameCommand_t;
}

void GameCommand_t::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    command_type_ = 0;
    playerid_ = 0;
    intvar1_ = 0;
    intvar2_ = 0;
    intvar3_ = 0;
    if (has_strvar1()) {
      if (strvar1_ != &::google::protobuf::internal::kEmptyString) {
        strvar1_->clear();
      }
    }
    if (has_strvar2()) {
      if (strvar2_ != &::google::protobuf::internal::kEmptyString) {
        strvar2_->clear();
      }
    }
    if (has_strvar3()) {
      if (strvar3_ != &::google::protobuf::internal::kEmptyString) {
        strvar3_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GameCommand_t::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 command_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &command_type_)));
          set_has_command_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_playerid;
        break;
      }

      // optional int32 playerid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_playerid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &playerid_)));
          set_has_playerid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_intvar1;
        break;
      }

      // optional int32 intvar1 = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_intvar1:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &intvar1_)));
          set_has_intvar1();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_intvar2;
        break;
      }

      // optional int32 intvar2 = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_intvar2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &intvar2_)));
          set_has_intvar2();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_intvar3;
        break;
      }

      // optional int32 intvar3 = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_intvar3:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &intvar3_)));
          set_has_intvar3();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_strvar1;
        break;
      }

      // optional string strvar1 = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_strvar1:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_strvar1()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_strvar2;
        break;
      }

      // optional string strvar2 = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_strvar2:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_strvar2()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_strvar3;
        break;
      }

      // optional string strvar3 = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_strvar3:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_strvar3()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GameCommand_t::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 command_type = 1;
  if (has_command_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->command_type(), output);
  }

  // optional int32 playerid = 2;
  if (has_playerid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->playerid(), output);
  }

  // optional int32 intvar1 = 3;
  if (has_intvar1()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->intvar1(), output);
  }

  // optional int32 intvar2 = 4;
  if (has_intvar2()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->intvar2(), output);
  }

  // optional int32 intvar3 = 5;
  if (has_intvar3()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->intvar3(), output);
  }

  // optional string strvar1 = 6;
  if (has_strvar1()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->strvar1(), output);
  }

  // optional string strvar2 = 7;
  if (has_strvar2()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      7, this->strvar2(), output);
  }

  // optional string strvar3 = 8;
  if (has_strvar3()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      8, this->strvar3(), output);
  }

}

int GameCommand_t::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 command_type = 1;
    if (has_command_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->command_type());
    }

    // optional int32 playerid = 2;
    if (has_playerid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->playerid());
    }

    // optional int32 intvar1 = 3;
    if (has_intvar1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->intvar1());
    }

    // optional int32 intvar2 = 4;
    if (has_intvar2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->intvar2());
    }

    // optional int32 intvar3 = 5;
    if (has_intvar3()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->intvar3());
    }

    // optional string strvar1 = 6;
    if (has_strvar1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->strvar1());
    }

    // optional string strvar2 = 7;
    if (has_strvar2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->strvar2());
    }

    // optional string strvar3 = 8;
    if (has_strvar3()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->strvar3());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GameCommand_t::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GameCommand_t*>(&from));
}

void GameCommand_t::MergeFrom(const GameCommand_t& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_command_type()) {
      set_command_type(from.command_type());
    }
    if (from.has_playerid()) {
      set_playerid(from.playerid());
    }
    if (from.has_intvar1()) {
      set_intvar1(from.intvar1());
    }
    if (from.has_intvar2()) {
      set_intvar2(from.intvar2());
    }
    if (from.has_intvar3()) {
      set_intvar3(from.intvar3());
    }
    if (from.has_strvar1()) {
      set_strvar1(from.strvar1());
    }
    if (from.has_strvar2()) {
      set_strvar2(from.strvar2());
    }
    if (from.has_strvar3()) {
      set_strvar3(from.strvar3());
    }
  }
}

void GameCommand_t::CopyFrom(const GameCommand_t& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameCommand_t::IsInitialized() const {

  return true;
}

void GameCommand_t::Swap(GameCommand_t* other) {
  if (other != this) {
    std::swap(command_type_, other->command_type_);
    std::swap(playerid_, other->playerid_);
    std::swap(intvar1_, other->intvar1_);
    std::swap(intvar2_, other->intvar2_);
    std::swap(intvar3_, other->intvar3_);
    std::swap(strvar1_, other->strvar1_);
    std::swap(strvar2_, other->strvar2_);
    std::swap(strvar3_, other->strvar3_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GameCommand_t::GetTypeName() const {
  return "proto.GameCommand_t";
}


// ===================================================================

#ifndef _MSC_VER
const int Login_req::kUserinfoFieldNumber;
#endif  // !_MSC_VER

Login_req::Login_req()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Login_req::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  userinfo_ = const_cast< ::proto::User_t*>(
      ::proto::User_t::internal_default_instance());
#else
  userinfo_ = const_cast< ::proto::User_t*>(&::proto::User_t::default_instance());
#endif
}

Login_req::Login_req(const Login_req& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Login_req::SharedCtor() {
  _cached_size_ = 0;
  userinfo_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Login_req::~Login_req() {
  SharedDtor();
}

void Login_req::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete userinfo_;
  }
}

void Login_req::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Login_req& Login_req::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GameMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GameMsg_2eproto();
#endif
  return *default_instance_;
}

Login_req* Login_req::default_instance_ = NULL;

Login_req* Login_req::New() const {
  return new Login_req;
}

void Login_req::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_userinfo()) {
      if (userinfo_ != NULL) userinfo_->::proto::User_t::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Login_req::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .proto.User_t userinfo = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_userinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Login_req::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .proto.User_t userinfo = 1;
  if (has_userinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->userinfo(), output);
  }

}

int Login_req::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .proto.User_t userinfo = 1;
    if (has_userinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->userinfo());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Login_req::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Login_req*>(&from));
}

void Login_req::MergeFrom(const Login_req& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_userinfo()) {
      mutable_userinfo()->::proto::User_t::MergeFrom(from.userinfo());
    }
  }
}

void Login_req::CopyFrom(const Login_req& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Login_req::IsInitialized() const {

  return true;
}

void Login_req::Swap(Login_req* other) {
  if (other != this) {
    std::swap(userinfo_, other->userinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Login_req::GetTypeName() const {
  return "proto.Login_req";
}


// ===================================================================

#ifndef _MSC_VER
const int Login_ack::kErrorCodeFieldNumber;
#endif  // !_MSC_VER

Login_ack::Login_ack()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Login_ack::InitAsDefaultInstance() {
}

Login_ack::Login_ack(const Login_ack& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Login_ack::SharedCtor() {
  _cached_size_ = 0;
  error_code_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Login_ack::~Login_ack() {
  SharedDtor();
}

void Login_ack::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Login_ack::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Login_ack& Login_ack::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GameMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GameMsg_2eproto();
#endif
  return *default_instance_;
}

Login_ack* Login_ack::default_instance_ = NULL;

Login_ack* Login_ack::New() const {
  return new Login_ack;
}

void Login_ack::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    error_code_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Login_ack::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .proto.ErrorCode_t error_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::proto::ErrorCode_t_IsValid(value)) {
            set_error_code(static_cast< ::proto::ErrorCode_t >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Login_ack::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .proto.ErrorCode_t error_code = 1;
  if (has_error_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->error_code(), output);
  }

}

int Login_ack::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .proto.ErrorCode_t error_code = 1;
    if (has_error_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->error_code());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Login_ack::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Login_ack*>(&from));
}

void Login_ack::MergeFrom(const Login_ack& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_error_code()) {
      set_error_code(from.error_code());
    }
  }
}

void Login_ack::CopyFrom(const Login_ack& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Login_ack::IsInitialized() const {

  return true;
}

void Login_ack::Swap(Login_ack* other) {
  if (other != this) {
    std::swap(error_code_, other->error_code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Login_ack::GetTypeName() const {
  return "proto.Login_ack";
}


// ===================================================================

#ifndef _MSC_VER
const int ListRoom_req::kOffsetFieldNumber;
#endif  // !_MSC_VER

ListRoom_req::ListRoom_req()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ListRoom_req::InitAsDefaultInstance() {
}

ListRoom_req::ListRoom_req(const ListRoom_req& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ListRoom_req::SharedCtor() {
  _cached_size_ = 0;
  offset_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ListRoom_req::~ListRoom_req() {
  SharedDtor();
}

void ListRoom_req::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ListRoom_req::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ListRoom_req& ListRoom_req::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GameMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GameMsg_2eproto();
#endif
  return *default_instance_;
}

ListRoom_req* ListRoom_req::default_instance_ = NULL;

ListRoom_req* ListRoom_req::New() const {
  return new ListRoom_req;
}

void ListRoom_req::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    offset_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ListRoom_req::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 offset = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &offset_)));
          set_has_offset();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ListRoom_req::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 offset = 1;
  if (has_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->offset(), output);
  }

}

int ListRoom_req::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 offset = 1;
    if (has_offset()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->offset());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ListRoom_req::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ListRoom_req*>(&from));
}

void ListRoom_req::MergeFrom(const ListRoom_req& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_offset()) {
      set_offset(from.offset());
    }
  }
}

void ListRoom_req::CopyFrom(const ListRoom_req& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListRoom_req::IsInitialized() const {

  return true;
}

void ListRoom_req::Swap(ListRoom_req* other) {
  if (other != this) {
    std::swap(offset_, other->offset_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ListRoom_req::GetTypeName() const {
  return "proto.ListRoom_req";
}


// ===================================================================

#ifndef _MSC_VER
const int ListRoom_ack::kErrorCodeFieldNumber;
const int ListRoom_ack::kRoomListFieldNumber;
#endif  // !_MSC_VER

ListRoom_ack::ListRoom_ack()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ListRoom_ack::InitAsDefaultInstance() {
}

ListRoom_ack::ListRoom_ack(const ListRoom_ack& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ListRoom_ack::SharedCtor() {
  _cached_size_ = 0;
  error_code_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ListRoom_ack::~ListRoom_ack() {
  SharedDtor();
}

void ListRoom_ack::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ListRoom_ack::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ListRoom_ack& ListRoom_ack::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GameMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GameMsg_2eproto();
#endif
  return *default_instance_;
}

ListRoom_ack* ListRoom_ack::default_instance_ = NULL;

ListRoom_ack* ListRoom_ack::New() const {
  return new ListRoom_ack;
}

void ListRoom_ack::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    error_code_ = 0;
  }
  room_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ListRoom_ack::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .proto.ErrorCode_t error_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::proto::ErrorCode_t_IsValid(value)) {
            set_error_code(static_cast< ::proto::ErrorCode_t >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_room_list;
        break;
      }

      // repeated .proto.Room_t room_list = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_room_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_room_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_room_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ListRoom_ack::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .proto.ErrorCode_t error_code = 1;
  if (has_error_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->error_code(), output);
  }

  // repeated .proto.Room_t room_list = 2;
  for (int i = 0; i < this->room_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->room_list(i), output);
  }

}

int ListRoom_ack::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .proto.ErrorCode_t error_code = 1;
    if (has_error_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->error_code());
    }

  }
  // repeated .proto.Room_t room_list = 2;
  total_size += 1 * this->room_list_size();
  for (int i = 0; i < this->room_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->room_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ListRoom_ack::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ListRoom_ack*>(&from));
}

void ListRoom_ack::MergeFrom(const ListRoom_ack& from) {
  GOOGLE_CHECK_NE(&from, this);
  room_list_.MergeFrom(from.room_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_error_code()) {
      set_error_code(from.error_code());
    }
  }
}

void ListRoom_ack::CopyFrom(const ListRoom_ack& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListRoom_ack::IsInitialized() const {

  return true;
}

void ListRoom_ack::Swap(ListRoom_ack* other) {
  if (other != this) {
    std::swap(error_code_, other->error_code_);
    room_list_.Swap(&other->room_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ListRoom_ack::GetTypeName() const {
  return "proto.ListRoom_ack";
}


// ===================================================================

#ifndef _MSC_VER
const int CreateRoom_req::kUseridFieldNumber;
const int CreateRoom_req::kRoomPasswordFieldNumber;
#endif  // !_MSC_VER

CreateRoom_req::CreateRoom_req()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CreateRoom_req::InitAsDefaultInstance() {
}

CreateRoom_req::CreateRoom_req(const CreateRoom_req& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CreateRoom_req::SharedCtor() {
  _cached_size_ = 0;
  userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  room_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CreateRoom_req::~CreateRoom_req() {
  SharedDtor();
}

void CreateRoom_req::SharedDtor() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    delete userid_;
  }
  if (room_password_ != &::google::protobuf::internal::kEmptyString) {
    delete room_password_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CreateRoom_req::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CreateRoom_req& CreateRoom_req::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GameMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GameMsg_2eproto();
#endif
  return *default_instance_;
}

CreateRoom_req* CreateRoom_req::default_instance_ = NULL;

CreateRoom_req* CreateRoom_req::New() const {
  return new CreateRoom_req;
}

void CreateRoom_req::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_userid()) {
      if (userid_ != &::google::protobuf::internal::kEmptyString) {
        userid_->clear();
      }
    }
    if (has_room_password()) {
      if (room_password_ != &::google::protobuf::internal::kEmptyString) {
        room_password_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CreateRoom_req::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string userid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_userid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_room_password;
        break;
      }

      // optional string room_password = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_room_password:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_room_password()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CreateRoom_req::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string userid = 1;
  if (has_userid()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->userid(), output);
  }

  // optional string room_password = 2;
  if (has_room_password()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->room_password(), output);
  }

}

int CreateRoom_req::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string userid = 1;
    if (has_userid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->userid());
    }

    // optional string room_password = 2;
    if (has_room_password()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->room_password());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CreateRoom_req::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CreateRoom_req*>(&from));
}

void CreateRoom_req::MergeFrom(const CreateRoom_req& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_userid()) {
      set_userid(from.userid());
    }
    if (from.has_room_password()) {
      set_room_password(from.room_password());
    }
  }
}

void CreateRoom_req::CopyFrom(const CreateRoom_req& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateRoom_req::IsInitialized() const {

  return true;
}

void CreateRoom_req::Swap(CreateRoom_req* other) {
  if (other != this) {
    std::swap(userid_, other->userid_);
    std::swap(room_password_, other->room_password_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CreateRoom_req::GetTypeName() const {
  return "proto.CreateRoom_req";
}


// ===================================================================

#ifndef _MSC_VER
const int CreateRoom_ack::kErrorCodeFieldNumber;
#endif  // !_MSC_VER

CreateRoom_ack::CreateRoom_ack()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CreateRoom_ack::InitAsDefaultInstance() {
}

CreateRoom_ack::CreateRoom_ack(const CreateRoom_ack& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CreateRoom_ack::SharedCtor() {
  _cached_size_ = 0;
  error_code_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CreateRoom_ack::~CreateRoom_ack() {
  SharedDtor();
}

void CreateRoom_ack::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CreateRoom_ack::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CreateRoom_ack& CreateRoom_ack::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GameMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GameMsg_2eproto();
#endif
  return *default_instance_;
}

CreateRoom_ack* CreateRoom_ack::default_instance_ = NULL;

CreateRoom_ack* CreateRoom_ack::New() const {
  return new CreateRoom_ack;
}

void CreateRoom_ack::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    error_code_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CreateRoom_ack::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .proto.ErrorCode_t error_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::proto::ErrorCode_t_IsValid(value)) {
            set_error_code(static_cast< ::proto::ErrorCode_t >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CreateRoom_ack::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .proto.ErrorCode_t error_code = 1;
  if (has_error_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->error_code(), output);
  }

}

int CreateRoom_ack::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .proto.ErrorCode_t error_code = 1;
    if (has_error_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->error_code());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CreateRoom_ack::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CreateRoom_ack*>(&from));
}

void CreateRoom_ack::MergeFrom(const CreateRoom_ack& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_error_code()) {
      set_error_code(from.error_code());
    }
  }
}

void CreateRoom_ack::CopyFrom(const CreateRoom_ack& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateRoom_ack::IsInitialized() const {

  return true;
}

void CreateRoom_ack::Swap(CreateRoom_ack* other) {
  if (other != this) {
    std::swap(error_code_, other->error_code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CreateRoom_ack::GetTypeName() const {
  return "proto.CreateRoom_ack";
}


// ===================================================================

#ifndef _MSC_VER
const int JoinRoom_req::kUseridFieldNumber;
const int JoinRoom_req::kRoomPasswordFieldNumber;
const int JoinRoom_req::kRoomNoFieldNumber;
const int JoinRoom_req::kPlayerinfoFieldNumber;
#endif  // !_MSC_VER

JoinRoom_req::JoinRoom_req()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void JoinRoom_req::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  playerinfo_ = const_cast< ::proto::Player_t*>(
      ::proto::Player_t::internal_default_instance());
#else
  playerinfo_ = const_cast< ::proto::Player_t*>(&::proto::Player_t::default_instance());
#endif
}

JoinRoom_req::JoinRoom_req(const JoinRoom_req& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void JoinRoom_req::SharedCtor() {
  _cached_size_ = 0;
  userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  room_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  room_no_ = 0;
  playerinfo_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

JoinRoom_req::~JoinRoom_req() {
  SharedDtor();
}

void JoinRoom_req::SharedDtor() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    delete userid_;
  }
  if (room_password_ != &::google::protobuf::internal::kEmptyString) {
    delete room_password_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete playerinfo_;
  }
}

void JoinRoom_req::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const JoinRoom_req& JoinRoom_req::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GameMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GameMsg_2eproto();
#endif
  return *default_instance_;
}

JoinRoom_req* JoinRoom_req::default_instance_ = NULL;

JoinRoom_req* JoinRoom_req::New() const {
  return new JoinRoom_req;
}

void JoinRoom_req::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_userid()) {
      if (userid_ != &::google::protobuf::internal::kEmptyString) {
        userid_->clear();
      }
    }
    if (has_room_password()) {
      if (room_password_ != &::google::protobuf::internal::kEmptyString) {
        room_password_->clear();
      }
    }
    room_no_ = 0;
    if (has_playerinfo()) {
      if (playerinfo_ != NULL) playerinfo_->::proto::Player_t::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool JoinRoom_req::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string userid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_userid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_room_password;
        break;
      }

      // optional string room_password = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_room_password:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_room_password()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_room_no;
        break;
      }

      // optional int32 room_no = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_room_no:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &room_no_)));
          set_has_room_no();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_playerinfo;
        break;
      }

      // optional .proto.Player_t playerinfo = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_playerinfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_playerinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void JoinRoom_req::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string userid = 1;
  if (has_userid()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->userid(), output);
  }

  // optional string room_password = 2;
  if (has_room_password()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->room_password(), output);
  }

  // optional int32 room_no = 3;
  if (has_room_no()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->room_no(), output);
  }

  // optional .proto.Player_t playerinfo = 4;
  if (has_playerinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->playerinfo(), output);
  }

}

int JoinRoom_req::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string userid = 1;
    if (has_userid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->userid());
    }

    // optional string room_password = 2;
    if (has_room_password()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->room_password());
    }

    // optional int32 room_no = 3;
    if (has_room_no()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->room_no());
    }

    // optional .proto.Player_t playerinfo = 4;
    if (has_playerinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->playerinfo());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void JoinRoom_req::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const JoinRoom_req*>(&from));
}

void JoinRoom_req::MergeFrom(const JoinRoom_req& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_userid()) {
      set_userid(from.userid());
    }
    if (from.has_room_password()) {
      set_room_password(from.room_password());
    }
    if (from.has_room_no()) {
      set_room_no(from.room_no());
    }
    if (from.has_playerinfo()) {
      mutable_playerinfo()->::proto::Player_t::MergeFrom(from.playerinfo());
    }
  }
}

void JoinRoom_req::CopyFrom(const JoinRoom_req& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JoinRoom_req::IsInitialized() const {

  return true;
}

void JoinRoom_req::Swap(JoinRoom_req* other) {
  if (other != this) {
    std::swap(userid_, other->userid_);
    std::swap(room_password_, other->room_password_);
    std::swap(room_no_, other->room_no_);
    std::swap(playerinfo_, other->playerinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string JoinRoom_req::GetTypeName() const {
  return "proto.JoinRoom_req";
}


// ===================================================================

#ifndef _MSC_VER
const int JoinRoom_ack::kErrorCodeFieldNumber;
const int JoinRoom_ack::kPlayeridFieldNumber;
#endif  // !_MSC_VER

JoinRoom_ack::JoinRoom_ack()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void JoinRoom_ack::InitAsDefaultInstance() {
}

JoinRoom_ack::JoinRoom_ack(const JoinRoom_ack& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void JoinRoom_ack::SharedCtor() {
  _cached_size_ = 0;
  error_code_ = 0;
  playerid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

JoinRoom_ack::~JoinRoom_ack() {
  SharedDtor();
}

void JoinRoom_ack::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void JoinRoom_ack::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const JoinRoom_ack& JoinRoom_ack::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GameMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GameMsg_2eproto();
#endif
  return *default_instance_;
}

JoinRoom_ack* JoinRoom_ack::default_instance_ = NULL;

JoinRoom_ack* JoinRoom_ack::New() const {
  return new JoinRoom_ack;
}

void JoinRoom_ack::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    error_code_ = 0;
    playerid_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool JoinRoom_ack::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .proto.ErrorCode_t error_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::proto::ErrorCode_t_IsValid(value)) {
            set_error_code(static_cast< ::proto::ErrorCode_t >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_playerid;
        break;
      }

      // optional int32 playerid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_playerid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &playerid_)));
          set_has_playerid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void JoinRoom_ack::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .proto.ErrorCode_t error_code = 1;
  if (has_error_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->error_code(), output);
  }

  // optional int32 playerid = 2;
  if (has_playerid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->playerid(), output);
  }

}

int JoinRoom_ack::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .proto.ErrorCode_t error_code = 1;
    if (has_error_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->error_code());
    }

    // optional int32 playerid = 2;
    if (has_playerid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->playerid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void JoinRoom_ack::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const JoinRoom_ack*>(&from));
}

void JoinRoom_ack::MergeFrom(const JoinRoom_ack& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_error_code()) {
      set_error_code(from.error_code());
    }
    if (from.has_playerid()) {
      set_playerid(from.playerid());
    }
  }
}

void JoinRoom_ack::CopyFrom(const JoinRoom_ack& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JoinRoom_ack::IsInitialized() const {

  return true;
}

void JoinRoom_ack::Swap(JoinRoom_ack* other) {
  if (other != this) {
    std::swap(error_code_, other->error_code_);
    std::swap(playerid_, other->playerid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string JoinRoom_ack::GetTypeName() const {
  return "proto.JoinRoom_ack";
}


// ===================================================================

#ifndef _MSC_VER
const int PlayerList_ntf::kPlayerListFieldNumber;
#endif  // !_MSC_VER

PlayerList_ntf::PlayerList_ntf()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void PlayerList_ntf::InitAsDefaultInstance() {
}

PlayerList_ntf::PlayerList_ntf(const PlayerList_ntf& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void PlayerList_ntf::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PlayerList_ntf::~PlayerList_ntf() {
  SharedDtor();
}

void PlayerList_ntf::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PlayerList_ntf::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PlayerList_ntf& PlayerList_ntf::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GameMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GameMsg_2eproto();
#endif
  return *default_instance_;
}

PlayerList_ntf* PlayerList_ntf::default_instance_ = NULL;

PlayerList_ntf* PlayerList_ntf::New() const {
  return new PlayerList_ntf;
}

void PlayerList_ntf::Clear() {
  player_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool PlayerList_ntf::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .proto.Player_t player_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_player_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_player_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_player_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PlayerList_ntf::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .proto.Player_t player_list = 1;
  for (int i = 0; i < this->player_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->player_list(i), output);
  }

}

int PlayerList_ntf::ByteSize() const {
  int total_size = 0;

  // repeated .proto.Player_t player_list = 1;
  total_size += 1 * this->player_list_size();
  for (int i = 0; i < this->player_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->player_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlayerList_ntf::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PlayerList_ntf*>(&from));
}

void PlayerList_ntf::MergeFrom(const PlayerList_ntf& from) {
  GOOGLE_CHECK_NE(&from, this);
  player_list_.MergeFrom(from.player_list_);
}

void PlayerList_ntf::CopyFrom(const PlayerList_ntf& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerList_ntf::IsInitialized() const {

  return true;
}

void PlayerList_ntf::Swap(PlayerList_ntf* other) {
  if (other != this) {
    player_list_.Swap(&other->player_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PlayerList_ntf::GetTypeName() const {
  return "proto.PlayerList_ntf";
}


// ===================================================================

#ifndef _MSC_VER
const int EnterGame_ntf::kPlayerListFieldNumber;
#endif  // !_MSC_VER

EnterGame_ntf::EnterGame_ntf()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void EnterGame_ntf::InitAsDefaultInstance() {
}

EnterGame_ntf::EnterGame_ntf(const EnterGame_ntf& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void EnterGame_ntf::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EnterGame_ntf::~EnterGame_ntf() {
  SharedDtor();
}

void EnterGame_ntf::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void EnterGame_ntf::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const EnterGame_ntf& EnterGame_ntf::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GameMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GameMsg_2eproto();
#endif
  return *default_instance_;
}

EnterGame_ntf* EnterGame_ntf::default_instance_ = NULL;

EnterGame_ntf* EnterGame_ntf::New() const {
  return new EnterGame_ntf;
}

void EnterGame_ntf::Clear() {
  player_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool EnterGame_ntf::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .proto.Player_t player_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_player_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_player_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_player_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void EnterGame_ntf::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .proto.Player_t player_list = 1;
  for (int i = 0; i < this->player_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->player_list(i), output);
  }

}

int EnterGame_ntf::ByteSize() const {
  int total_size = 0;

  // repeated .proto.Player_t player_list = 1;
  total_size += 1 * this->player_list_size();
  for (int i = 0; i < this->player_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->player_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EnterGame_ntf::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const EnterGame_ntf*>(&from));
}

void EnterGame_ntf::MergeFrom(const EnterGame_ntf& from) {
  GOOGLE_CHECK_NE(&from, this);
  player_list_.MergeFrom(from.player_list_);
}

void EnterGame_ntf::CopyFrom(const EnterGame_ntf& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EnterGame_ntf::IsInitialized() const {

  return true;
}

void EnterGame_ntf::Swap(EnterGame_ntf* other) {
  if (other != this) {
    player_list_.Swap(&other->player_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string EnterGame_ntf::GetTypeName() const {
  return "proto.EnterGame_ntf";
}


// ===================================================================

#ifndef _MSC_VER
const int EnterGameOk_req::kPlayeridFieldNumber;
#endif  // !_MSC_VER

EnterGameOk_req::EnterGameOk_req()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void EnterGameOk_req::InitAsDefaultInstance() {
}

EnterGameOk_req::EnterGameOk_req(const EnterGameOk_req& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void EnterGameOk_req::SharedCtor() {
  _cached_size_ = 0;
  playerid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EnterGameOk_req::~EnterGameOk_req() {
  SharedDtor();
}

void EnterGameOk_req::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void EnterGameOk_req::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const EnterGameOk_req& EnterGameOk_req::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GameMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GameMsg_2eproto();
#endif
  return *default_instance_;
}

EnterGameOk_req* EnterGameOk_req::default_instance_ = NULL;

EnterGameOk_req* EnterGameOk_req::New() const {
  return new EnterGameOk_req;
}

void EnterGameOk_req::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    playerid_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool EnterGameOk_req::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 playerid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &playerid_)));
          set_has_playerid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void EnterGameOk_req::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 playerid = 1;
  if (has_playerid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->playerid(), output);
  }

}

int EnterGameOk_req::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 playerid = 1;
    if (has_playerid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->playerid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EnterGameOk_req::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const EnterGameOk_req*>(&from));
}

void EnterGameOk_req::MergeFrom(const EnterGameOk_req& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_playerid()) {
      set_playerid(from.playerid());
    }
  }
}

void EnterGameOk_req::CopyFrom(const EnterGameOk_req& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EnterGameOk_req::IsInitialized() const {

  return true;
}

void EnterGameOk_req::Swap(EnterGameOk_req* other) {
  if (other != this) {
    std::swap(playerid_, other->playerid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string EnterGameOk_req::GetTypeName() const {
  return "proto.EnterGameOk_req";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

StartRace_ntf::StartRace_ntf()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void StartRace_ntf::InitAsDefaultInstance() {
}

StartRace_ntf::StartRace_ntf(const StartRace_ntf& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void StartRace_ntf::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StartRace_ntf::~StartRace_ntf() {
  SharedDtor();
}

void StartRace_ntf::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void StartRace_ntf::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StartRace_ntf& StartRace_ntf::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GameMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GameMsg_2eproto();
#endif
  return *default_instance_;
}

StartRace_ntf* StartRace_ntf::default_instance_ = NULL;

StartRace_ntf* StartRace_ntf::New() const {
  return new StartRace_ntf;
}

void StartRace_ntf::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool StartRace_ntf::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
  }
  return true;
#undef DO_
}

void StartRace_ntf::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
}

int StartRace_ntf::ByteSize() const {
  int total_size = 0;

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StartRace_ntf::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StartRace_ntf*>(&from));
}

void StartRace_ntf::MergeFrom(const StartRace_ntf& from) {
  GOOGLE_CHECK_NE(&from, this);
}

void StartRace_ntf::CopyFrom(const StartRace_ntf& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StartRace_ntf::IsInitialized() const {

  return true;
}

void StartRace_ntf::Swap(StartRace_ntf* other) {
  if (other != this) {
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string StartRace_ntf::GetTypeName() const {
  return "proto.StartRace_ntf";
}


// ===================================================================

#ifndef _MSC_VER
const int LogicFrame_ntf::kFrameNoFieldNumber;
const int LogicFrame_ntf::kCommandListFieldNumber;
#endif  // !_MSC_VER

LogicFrame_ntf::LogicFrame_ntf()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LogicFrame_ntf::InitAsDefaultInstance() {
}

LogicFrame_ntf::LogicFrame_ntf(const LogicFrame_ntf& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LogicFrame_ntf::SharedCtor() {
  _cached_size_ = 0;
  frame_no_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LogicFrame_ntf::~LogicFrame_ntf() {
  SharedDtor();
}

void LogicFrame_ntf::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LogicFrame_ntf::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LogicFrame_ntf& LogicFrame_ntf::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GameMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GameMsg_2eproto();
#endif
  return *default_instance_;
}

LogicFrame_ntf* LogicFrame_ntf::default_instance_ = NULL;

LogicFrame_ntf* LogicFrame_ntf::New() const {
  return new LogicFrame_ntf;
}

void LogicFrame_ntf::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    frame_no_ = 0;
  }
  command_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LogicFrame_ntf::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 frame_no = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &frame_no_)));
          set_has_frame_no();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_command_list;
        break;
      }

      // repeated .proto.GameCommand_t command_list = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_command_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_command_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_command_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LogicFrame_ntf::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 frame_no = 1;
  if (has_frame_no()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->frame_no(), output);
  }

  // repeated .proto.GameCommand_t command_list = 2;
  for (int i = 0; i < this->command_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->command_list(i), output);
  }

}

int LogicFrame_ntf::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 frame_no = 1;
    if (has_frame_no()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->frame_no());
    }

  }
  // repeated .proto.GameCommand_t command_list = 2;
  total_size += 1 * this->command_list_size();
  for (int i = 0; i < this->command_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->command_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LogicFrame_ntf::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LogicFrame_ntf*>(&from));
}

void LogicFrame_ntf::MergeFrom(const LogicFrame_ntf& from) {
  GOOGLE_CHECK_NE(&from, this);
  command_list_.MergeFrom(from.command_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_frame_no()) {
      set_frame_no(from.frame_no());
    }
  }
}

void LogicFrame_ntf::CopyFrom(const LogicFrame_ntf& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogicFrame_ntf::IsInitialized() const {

  return true;
}

void LogicFrame_ntf::Swap(LogicFrame_ntf* other) {
  if (other != this) {
    std::swap(frame_no_, other->frame_no_);
    command_list_.Swap(&other->command_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LogicFrame_ntf::GetTypeName() const {
  return "proto.LogicFrame_ntf";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto

// @@protoc_insertion_point(global_scope)
