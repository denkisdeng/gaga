// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GameMsg.proto

#ifndef PROTOBUF_GameMsg_2eproto__INCLUDED
#define PROTOBUF_GameMsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_GameMsg_2eproto();
void protobuf_AssignDesc_GameMsg_2eproto();
void protobuf_ShutdownFile_GameMsg_2eproto();

class User_t;
class Room_t;
class Player_t;
class GameCommand_t;
class Login_req;
class Login_ack;
class ListRoom_req;
class ListRoom_ack;
class CreateRoom_req;
class CreateRoom_ack;
class JoinRoom_req;
class JoinRoom_ack;
class PlayerList_ntf;
class EnterGame_ntf;
class EnterGameOk_req;
class StartRace_ntf;
class LogicFrame_ntf;

enum ErrorCode_t {
  CODE_OK = 0,
  CODE_ROOM_NOT_EXIST = 1,
  CODE_ROOM_PW_NOT_RIGHT = 2,
  CODE_ROOM_FULL = 3,
  NEWS = 4,
  PRODUCTS = 5,
  VIDEO = 6
};
bool ErrorCode_t_IsValid(int value);
const ErrorCode_t ErrorCode_t_MIN = CODE_OK;
const ErrorCode_t ErrorCode_t_MAX = VIDEO;
const int ErrorCode_t_ARRAYSIZE = ErrorCode_t_MAX + 1;

enum GameMsgId_t {
  MSG_RESERVE = 135,
  MSG_LOGIN_REQ = 136,
  MSG_LOGIN_ACK = 137,
  MSG_LIST_ROOM_REQ = 138,
  MSG_LIST_ROOM_ACK = 139,
  MSG_CREATE_ROOM_REQ = 140,
  MSG_CREATE_ROOM_ACK = 141,
  MSG_JOIN_ROOM_REQ = 142,
  MSG_JOIN_ROOM_ACK = 143,
  MSG_PLAYER_LIST_NTF = 144,
  MSG_ENTER_GAME_NTF = 145,
  MSG_ENTER_GAME_OK_REQ = 146,
  MSG_START_RACE_NTF = 147,
  MSG_LOGIC_FRAME_NTF = 148
};
bool GameMsgId_t_IsValid(int value);
const GameMsgId_t GameMsgId_t_MIN = MSG_RESERVE;
const GameMsgId_t GameMsgId_t_MAX = MSG_LOGIC_FRAME_NTF;
const int GameMsgId_t_ARRAYSIZE = GameMsgId_t_MAX + 1;

enum GameCommandType_t {
  CMD_STEER = 1
};
bool GameCommandType_t_IsValid(int value);
const GameCommandType_t GameCommandType_t_MIN = CMD_STEER;
const GameCommandType_t GameCommandType_t_MAX = CMD_STEER;
const int GameCommandType_t_ARRAYSIZE = GameCommandType_t_MAX + 1;

// ===================================================================

class User_t : public ::google::protobuf::MessageLite {
 public:
  User_t();
  virtual ~User_t();

  User_t(const User_t& from);

  inline User_t& operator=(const User_t& from) {
    CopyFrom(from);
    return *this;
  }

  static const User_t& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const User_t* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(User_t* other);

  // implements Message ----------------------------------------------

  User_t* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const User_t& from);
  void MergeFrom(const User_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string userid = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 1;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  inline void set_allocated_userid(::std::string* userid);

  // optional string nickname = 2;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 2;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // @@protoc_insertion_point(class_scope:proto.User_t)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_nickname();
  inline void clear_has_nickname();

  ::std::string* userid_;
  ::std::string* nickname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GameMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GameMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_GameMsg_2eproto();
  friend void protobuf_ShutdownFile_GameMsg_2eproto();

  void InitAsDefaultInstance();
  static User_t* default_instance_;
};
// -------------------------------------------------------------------

class Room_t : public ::google::protobuf::MessageLite {
 public:
  Room_t();
  virtual ~Room_t();

  Room_t(const Room_t& from);

  inline Room_t& operator=(const Room_t& from) {
    CopyFrom(from);
    return *this;
  }

  static const Room_t& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Room_t* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Room_t* other);

  // implements Message ----------------------------------------------

  Room_t* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Room_t& from);
  void MergeFrom(const Room_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 room_no = 1;
  inline bool has_room_no() const;
  inline void clear_room_no();
  static const int kRoomNoFieldNumber = 1;
  inline ::google::protobuf::int32 room_no() const;
  inline void set_room_no(::google::protobuf::int32 value);

  // optional string desp = 2;
  inline bool has_desp() const;
  inline void clear_desp();
  static const int kDespFieldNumber = 2;
  inline const ::std::string& desp() const;
  inline void set_desp(const ::std::string& value);
  inline void set_desp(const char* value);
  inline void set_desp(const char* value, size_t size);
  inline ::std::string* mutable_desp();
  inline ::std::string* release_desp();
  inline void set_allocated_desp(::std::string* desp);

  // @@protoc_insertion_point(class_scope:proto.Room_t)
 private:
  inline void set_has_room_no();
  inline void clear_has_room_no();
  inline void set_has_desp();
  inline void clear_has_desp();

  ::std::string* desp_;
  ::google::protobuf::int32 room_no_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GameMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GameMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_GameMsg_2eproto();
  friend void protobuf_ShutdownFile_GameMsg_2eproto();

  void InitAsDefaultInstance();
  static Room_t* default_instance_;
};
// -------------------------------------------------------------------

class Player_t : public ::google::protobuf::MessageLite {
 public:
  Player_t();
  virtual ~Player_t();

  Player_t(const Player_t& from);

  inline Player_t& operator=(const Player_t& from) {
    CopyFrom(from);
    return *this;
  }

  static const Player_t& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Player_t* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Player_t* other);

  // implements Message ----------------------------------------------

  Player_t* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Player_t& from);
  void MergeFrom(const Player_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 playerid = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 1;
  inline ::google::protobuf::int32 playerid() const;
  inline void set_playerid(::google::protobuf::int32 value);

  // optional string userid = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 2;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  inline void set_allocated_userid(::std::string* userid);

  // optional string car_name = 3;
  inline bool has_car_name() const;
  inline void clear_car_name();
  static const int kCarNameFieldNumber = 3;
  inline const ::std::string& car_name() const;
  inline void set_car_name(const ::std::string& value);
  inline void set_car_name(const char* value);
  inline void set_car_name(const char* value, size_t size);
  inline ::std::string* mutable_car_name();
  inline ::std::string* release_car_name();
  inline void set_allocated_car_name(::std::string* car_name);

  // optional int32 is_free = 4;
  inline bool has_is_free() const;
  inline void clear_is_free();
  static const int kIsFreeFieldNumber = 4;
  inline ::google::protobuf::int32 is_free() const;
  inline void set_is_free(::google::protobuf::int32 value);

  // optional int32 is_owned = 5;
  inline bool has_is_owned() const;
  inline void clear_is_owned();
  static const int kIsOwnedFieldNumber = 5;
  inline ::google::protobuf::int32 is_owned() const;
  inline void set_is_owned(::google::protobuf::int32 value);

  // optional int32 stage = 6;
  inline bool has_stage() const;
  inline void clear_stage();
  static const int kStageFieldNumber = 6;
  inline ::google::protobuf::int32 stage() const;
  inline void set_stage(::google::protobuf::int32 value);

  // optional string decal = 7;
  inline bool has_decal() const;
  inline void clear_decal();
  static const int kDecalFieldNumber = 7;
  inline const ::std::string& decal() const;
  inline void set_decal(const ::std::string& value);
  inline void set_decal(const char* value);
  inline void set_decal(const char* value, size_t size);
  inline ::std::string* mutable_decal();
  inline ::std::string* release_decal();
  inline void set_allocated_decal(::std::string* decal);

  // optional string decal_color = 8;
  inline bool has_decal_color() const;
  inline void clear_decal_color();
  static const int kDecalColorFieldNumber = 8;
  inline const ::std::string& decal_color() const;
  inline void set_decal_color(const ::std::string& value);
  inline void set_decal_color(const char* value);
  inline void set_decal_color(const char* value, size_t size);
  inline ::std::string* mutable_decal_color();
  inline ::std::string* release_decal_color();
  inline void set_allocated_decal_color(::std::string* decal_color);

  // optional string driver_name = 9;
  inline bool has_driver_name() const;
  inline void clear_driver_name();
  static const int kDriverNameFieldNumber = 9;
  inline const ::std::string& driver_name() const;
  inline void set_driver_name(const ::std::string& value);
  inline void set_driver_name(const char* value);
  inline void set_driver_name(const char* value, size_t size);
  inline ::std::string* mutable_driver_name();
  inline ::std::string* release_driver_name();
  inline void set_allocated_driver_name(::std::string* driver_name);

  // optional string driver_type = 10;
  inline bool has_driver_type() const;
  inline void clear_driver_type();
  static const int kDriverTypeFieldNumber = 10;
  inline const ::std::string& driver_type() const;
  inline void set_driver_type(const ::std::string& value);
  inline void set_driver_type(const char* value);
  inline void set_driver_type(const char* value, size_t size);
  inline ::std::string* mutable_driver_type();
  inline ::std::string* release_driver_type();
  inline void set_allocated_driver_type(::std::string* driver_type);

  // optional int32 accel = 11;
  inline bool has_accel() const;
  inline void clear_accel();
  static const int kAccelFieldNumber = 11;
  inline ::google::protobuf::int32 accel() const;
  inline void set_accel(::google::protobuf::int32 value);

  // optional int32 speed = 12;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 12;
  inline ::google::protobuf::int32 speed() const;
  inline void set_speed(::google::protobuf::int32 value);

  // optional int32 handling = 13;
  inline bool has_handling() const;
  inline void clear_handling();
  static const int kHandlingFieldNumber = 13;
  inline ::google::protobuf::int32 handling() const;
  inline void set_handling(::google::protobuf::int32 value);

  // optional int32 tough = 14;
  inline bool has_tough() const;
  inline void clear_tough();
  static const int kToughFieldNumber = 14;
  inline ::google::protobuf::int32 tough() const;
  inline void set_tough(::google::protobuf::int32 value);

  // optional int32 is_gold = 15;
  inline bool has_is_gold() const;
  inline void clear_is_gold();
  static const int kIsGoldFieldNumber = 15;
  inline ::google::protobuf::int32 is_gold() const;
  inline void set_is_gold(::google::protobuf::int32 value);

  // optional int32 min_stage = 16;
  inline bool has_min_stage() const;
  inline void clear_min_stage();
  static const int kMinStageFieldNumber = 16;
  inline ::google::protobuf::int32 min_stage() const;
  inline void set_min_stage(::google::protobuf::int32 value);

  // optional int32 max_stage = 17;
  inline bool has_max_stage() const;
  inline void clear_max_stage();
  static const int kMaxStageFieldNumber = 17;
  inline ::google::protobuf::int32 max_stage() const;
  inline void set_max_stage(::google::protobuf::int32 value);

  // optional string paint_color = 18;
  inline bool has_paint_color() const;
  inline void clear_paint_color();
  static const int kPaintColorFieldNumber = 18;
  inline const ::std::string& paint_color() const;
  inline void set_paint_color(const ::std::string& value);
  inline void set_paint_color(const char* value);
  inline void set_paint_color(const char* value, size_t size);
  inline ::std::string* mutable_paint_color();
  inline ::std::string* release_paint_color();
  inline void set_allocated_paint_color(::std::string* paint_color);

  // @@protoc_insertion_point(class_scope:proto.Player_t)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_car_name();
  inline void clear_has_car_name();
  inline void set_has_is_free();
  inline void clear_has_is_free();
  inline void set_has_is_owned();
  inline void clear_has_is_owned();
  inline void set_has_stage();
  inline void clear_has_stage();
  inline void set_has_decal();
  inline void clear_has_decal();
  inline void set_has_decal_color();
  inline void clear_has_decal_color();
  inline void set_has_driver_name();
  inline void clear_has_driver_name();
  inline void set_has_driver_type();
  inline void clear_has_driver_type();
  inline void set_has_accel();
  inline void clear_has_accel();
  inline void set_has_speed();
  inline void clear_has_speed();
  inline void set_has_handling();
  inline void clear_has_handling();
  inline void set_has_tough();
  inline void clear_has_tough();
  inline void set_has_is_gold();
  inline void clear_has_is_gold();
  inline void set_has_min_stage();
  inline void clear_has_min_stage();
  inline void set_has_max_stage();
  inline void clear_has_max_stage();
  inline void set_has_paint_color();
  inline void clear_has_paint_color();

  ::std::string* userid_;
  ::google::protobuf::int32 playerid_;
  ::google::protobuf::int32 is_free_;
  ::std::string* car_name_;
  ::google::protobuf::int32 is_owned_;
  ::google::protobuf::int32 stage_;
  ::std::string* decal_;
  ::std::string* decal_color_;
  ::std::string* driver_name_;
  ::std::string* driver_type_;
  ::google::protobuf::int32 accel_;
  ::google::protobuf::int32 speed_;
  ::google::protobuf::int32 handling_;
  ::google::protobuf::int32 tough_;
  ::google::protobuf::int32 is_gold_;
  ::google::protobuf::int32 min_stage_;
  ::std::string* paint_color_;
  ::google::protobuf::int32 max_stage_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GameMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GameMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_GameMsg_2eproto();
  friend void protobuf_ShutdownFile_GameMsg_2eproto();

  void InitAsDefaultInstance();
  static Player_t* default_instance_;
};
// -------------------------------------------------------------------

class GameCommand_t : public ::google::protobuf::MessageLite {
 public:
  GameCommand_t();
  virtual ~GameCommand_t();

  GameCommand_t(const GameCommand_t& from);

  inline GameCommand_t& operator=(const GameCommand_t& from) {
    CopyFrom(from);
    return *this;
  }

  static const GameCommand_t& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GameCommand_t* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GameCommand_t* other);

  // implements Message ----------------------------------------------

  GameCommand_t* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GameCommand_t& from);
  void MergeFrom(const GameCommand_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 command_type = 1;
  inline bool has_command_type() const;
  inline void clear_command_type();
  static const int kCommandTypeFieldNumber = 1;
  inline ::google::protobuf::int32 command_type() const;
  inline void set_command_type(::google::protobuf::int32 value);

  // optional int32 playerid = 2;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 2;
  inline ::google::protobuf::int32 playerid() const;
  inline void set_playerid(::google::protobuf::int32 value);

  // optional int32 intvar1 = 3;
  inline bool has_intvar1() const;
  inline void clear_intvar1();
  static const int kIntvar1FieldNumber = 3;
  inline ::google::protobuf::int32 intvar1() const;
  inline void set_intvar1(::google::protobuf::int32 value);

  // optional int32 intvar2 = 4;
  inline bool has_intvar2() const;
  inline void clear_intvar2();
  static const int kIntvar2FieldNumber = 4;
  inline ::google::protobuf::int32 intvar2() const;
  inline void set_intvar2(::google::protobuf::int32 value);

  // optional int32 intvar3 = 5;
  inline bool has_intvar3() const;
  inline void clear_intvar3();
  static const int kIntvar3FieldNumber = 5;
  inline ::google::protobuf::int32 intvar3() const;
  inline void set_intvar3(::google::protobuf::int32 value);

  // optional string strvar1 = 6;
  inline bool has_strvar1() const;
  inline void clear_strvar1();
  static const int kStrvar1FieldNumber = 6;
  inline const ::std::string& strvar1() const;
  inline void set_strvar1(const ::std::string& value);
  inline void set_strvar1(const char* value);
  inline void set_strvar1(const char* value, size_t size);
  inline ::std::string* mutable_strvar1();
  inline ::std::string* release_strvar1();
  inline void set_allocated_strvar1(::std::string* strvar1);

  // optional string strvar2 = 7;
  inline bool has_strvar2() const;
  inline void clear_strvar2();
  static const int kStrvar2FieldNumber = 7;
  inline const ::std::string& strvar2() const;
  inline void set_strvar2(const ::std::string& value);
  inline void set_strvar2(const char* value);
  inline void set_strvar2(const char* value, size_t size);
  inline ::std::string* mutable_strvar2();
  inline ::std::string* release_strvar2();
  inline void set_allocated_strvar2(::std::string* strvar2);

  // optional string strvar3 = 8;
  inline bool has_strvar3() const;
  inline void clear_strvar3();
  static const int kStrvar3FieldNumber = 8;
  inline const ::std::string& strvar3() const;
  inline void set_strvar3(const ::std::string& value);
  inline void set_strvar3(const char* value);
  inline void set_strvar3(const char* value, size_t size);
  inline ::std::string* mutable_strvar3();
  inline ::std::string* release_strvar3();
  inline void set_allocated_strvar3(::std::string* strvar3);

  // @@protoc_insertion_point(class_scope:proto.GameCommand_t)
 private:
  inline void set_has_command_type();
  inline void clear_has_command_type();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_intvar1();
  inline void clear_has_intvar1();
  inline void set_has_intvar2();
  inline void clear_has_intvar2();
  inline void set_has_intvar3();
  inline void clear_has_intvar3();
  inline void set_has_strvar1();
  inline void clear_has_strvar1();
  inline void set_has_strvar2();
  inline void clear_has_strvar2();
  inline void set_has_strvar3();
  inline void clear_has_strvar3();

  ::google::protobuf::int32 command_type_;
  ::google::protobuf::int32 playerid_;
  ::google::protobuf::int32 intvar1_;
  ::google::protobuf::int32 intvar2_;
  ::std::string* strvar1_;
  ::std::string* strvar2_;
  ::std::string* strvar3_;
  ::google::protobuf::int32 intvar3_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GameMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GameMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_GameMsg_2eproto();
  friend void protobuf_ShutdownFile_GameMsg_2eproto();

  void InitAsDefaultInstance();
  static GameCommand_t* default_instance_;
};
// -------------------------------------------------------------------

class Login_req : public ::google::protobuf::MessageLite {
 public:
  Login_req();
  virtual ~Login_req();

  Login_req(const Login_req& from);

  inline Login_req& operator=(const Login_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const Login_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Login_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Login_req* other);

  // implements Message ----------------------------------------------

  Login_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Login_req& from);
  void MergeFrom(const Login_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.User_t userinfo = 1;
  inline bool has_userinfo() const;
  inline void clear_userinfo();
  static const int kUserinfoFieldNumber = 1;
  inline const ::proto::User_t& userinfo() const;
  inline ::proto::User_t* mutable_userinfo();
  inline ::proto::User_t* release_userinfo();
  inline void set_allocated_userinfo(::proto::User_t* userinfo);

  // @@protoc_insertion_point(class_scope:proto.Login_req)
 private:
  inline void set_has_userinfo();
  inline void clear_has_userinfo();

  ::proto::User_t* userinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GameMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GameMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_GameMsg_2eproto();
  friend void protobuf_ShutdownFile_GameMsg_2eproto();

  void InitAsDefaultInstance();
  static Login_req* default_instance_;
};
// -------------------------------------------------------------------

class Login_ack : public ::google::protobuf::MessageLite {
 public:
  Login_ack();
  virtual ~Login_ack();

  Login_ack(const Login_ack& from);

  inline Login_ack& operator=(const Login_ack& from) {
    CopyFrom(from);
    return *this;
  }

  static const Login_ack& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Login_ack* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Login_ack* other);

  // implements Message ----------------------------------------------

  Login_ack* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Login_ack& from);
  void MergeFrom(const Login_ack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.ErrorCode_t error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::proto::ErrorCode_t error_code() const;
  inline void set_error_code(::proto::ErrorCode_t value);

  // @@protoc_insertion_point(class_scope:proto.Login_ack)
 private:
  inline void set_has_error_code();
  inline void clear_has_error_code();

  int error_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GameMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GameMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_GameMsg_2eproto();
  friend void protobuf_ShutdownFile_GameMsg_2eproto();

  void InitAsDefaultInstance();
  static Login_ack* default_instance_;
};
// -------------------------------------------------------------------

class ListRoom_req : public ::google::protobuf::MessageLite {
 public:
  ListRoom_req();
  virtual ~ListRoom_req();

  ListRoom_req(const ListRoom_req& from);

  inline ListRoom_req& operator=(const ListRoom_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const ListRoom_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ListRoom_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ListRoom_req* other);

  // implements Message ----------------------------------------------

  ListRoom_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ListRoom_req& from);
  void MergeFrom(const ListRoom_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 offset = 1;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 1;
  inline ::google::protobuf::int32 offset() const;
  inline void set_offset(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.ListRoom_req)
 private:
  inline void set_has_offset();
  inline void clear_has_offset();

  ::google::protobuf::int32 offset_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GameMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GameMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_GameMsg_2eproto();
  friend void protobuf_ShutdownFile_GameMsg_2eproto();

  void InitAsDefaultInstance();
  static ListRoom_req* default_instance_;
};
// -------------------------------------------------------------------

class ListRoom_ack : public ::google::protobuf::MessageLite {
 public:
  ListRoom_ack();
  virtual ~ListRoom_ack();

  ListRoom_ack(const ListRoom_ack& from);

  inline ListRoom_ack& operator=(const ListRoom_ack& from) {
    CopyFrom(from);
    return *this;
  }

  static const ListRoom_ack& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ListRoom_ack* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ListRoom_ack* other);

  // implements Message ----------------------------------------------

  ListRoom_ack* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ListRoom_ack& from);
  void MergeFrom(const ListRoom_ack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.ErrorCode_t error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::proto::ErrorCode_t error_code() const;
  inline void set_error_code(::proto::ErrorCode_t value);

  // repeated .proto.Room_t room_list = 2;
  inline int room_list_size() const;
  inline void clear_room_list();
  static const int kRoomListFieldNumber = 2;
  inline const ::proto::Room_t& room_list(int index) const;
  inline ::proto::Room_t* mutable_room_list(int index);
  inline ::proto::Room_t* add_room_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::Room_t >&
      room_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::Room_t >*
      mutable_room_list();

  // @@protoc_insertion_point(class_scope:proto.ListRoom_ack)
 private:
  inline void set_has_error_code();
  inline void clear_has_error_code();

  ::google::protobuf::RepeatedPtrField< ::proto::Room_t > room_list_;
  int error_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GameMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GameMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_GameMsg_2eproto();
  friend void protobuf_ShutdownFile_GameMsg_2eproto();

  void InitAsDefaultInstance();
  static ListRoom_ack* default_instance_;
};
// -------------------------------------------------------------------

class CreateRoom_req : public ::google::protobuf::MessageLite {
 public:
  CreateRoom_req();
  virtual ~CreateRoom_req();

  CreateRoom_req(const CreateRoom_req& from);

  inline CreateRoom_req& operator=(const CreateRoom_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const CreateRoom_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CreateRoom_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CreateRoom_req* other);

  // implements Message ----------------------------------------------

  CreateRoom_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CreateRoom_req& from);
  void MergeFrom(const CreateRoom_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string userid = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 1;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  inline void set_allocated_userid(::std::string* userid);

  // optional string room_password = 2;
  inline bool has_room_password() const;
  inline void clear_room_password();
  static const int kRoomPasswordFieldNumber = 2;
  inline const ::std::string& room_password() const;
  inline void set_room_password(const ::std::string& value);
  inline void set_room_password(const char* value);
  inline void set_room_password(const char* value, size_t size);
  inline ::std::string* mutable_room_password();
  inline ::std::string* release_room_password();
  inline void set_allocated_room_password(::std::string* room_password);

  // @@protoc_insertion_point(class_scope:proto.CreateRoom_req)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_room_password();
  inline void clear_has_room_password();

  ::std::string* userid_;
  ::std::string* room_password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GameMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GameMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_GameMsg_2eproto();
  friend void protobuf_ShutdownFile_GameMsg_2eproto();

  void InitAsDefaultInstance();
  static CreateRoom_req* default_instance_;
};
// -------------------------------------------------------------------

class CreateRoom_ack : public ::google::protobuf::MessageLite {
 public:
  CreateRoom_ack();
  virtual ~CreateRoom_ack();

  CreateRoom_ack(const CreateRoom_ack& from);

  inline CreateRoom_ack& operator=(const CreateRoom_ack& from) {
    CopyFrom(from);
    return *this;
  }

  static const CreateRoom_ack& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CreateRoom_ack* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CreateRoom_ack* other);

  // implements Message ----------------------------------------------

  CreateRoom_ack* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CreateRoom_ack& from);
  void MergeFrom(const CreateRoom_ack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.ErrorCode_t error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::proto::ErrorCode_t error_code() const;
  inline void set_error_code(::proto::ErrorCode_t value);

  // @@protoc_insertion_point(class_scope:proto.CreateRoom_ack)
 private:
  inline void set_has_error_code();
  inline void clear_has_error_code();

  int error_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GameMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GameMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_GameMsg_2eproto();
  friend void protobuf_ShutdownFile_GameMsg_2eproto();

  void InitAsDefaultInstance();
  static CreateRoom_ack* default_instance_;
};
// -------------------------------------------------------------------

class JoinRoom_req : public ::google::protobuf::MessageLite {
 public:
  JoinRoom_req();
  virtual ~JoinRoom_req();

  JoinRoom_req(const JoinRoom_req& from);

  inline JoinRoom_req& operator=(const JoinRoom_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const JoinRoom_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const JoinRoom_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(JoinRoom_req* other);

  // implements Message ----------------------------------------------

  JoinRoom_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const JoinRoom_req& from);
  void MergeFrom(const JoinRoom_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string userid = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 1;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  inline void set_allocated_userid(::std::string* userid);

  // optional string room_password = 2;
  inline bool has_room_password() const;
  inline void clear_room_password();
  static const int kRoomPasswordFieldNumber = 2;
  inline const ::std::string& room_password() const;
  inline void set_room_password(const ::std::string& value);
  inline void set_room_password(const char* value);
  inline void set_room_password(const char* value, size_t size);
  inline ::std::string* mutable_room_password();
  inline ::std::string* release_room_password();
  inline void set_allocated_room_password(::std::string* room_password);

  // optional int32 room_no = 3;
  inline bool has_room_no() const;
  inline void clear_room_no();
  static const int kRoomNoFieldNumber = 3;
  inline ::google::protobuf::int32 room_no() const;
  inline void set_room_no(::google::protobuf::int32 value);

  // optional .proto.Player_t playerinfo = 4;
  inline bool has_playerinfo() const;
  inline void clear_playerinfo();
  static const int kPlayerinfoFieldNumber = 4;
  inline const ::proto::Player_t& playerinfo() const;
  inline ::proto::Player_t* mutable_playerinfo();
  inline ::proto::Player_t* release_playerinfo();
  inline void set_allocated_playerinfo(::proto::Player_t* playerinfo);

  // @@protoc_insertion_point(class_scope:proto.JoinRoom_req)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_room_password();
  inline void clear_has_room_password();
  inline void set_has_room_no();
  inline void clear_has_room_no();
  inline void set_has_playerinfo();
  inline void clear_has_playerinfo();

  ::std::string* userid_;
  ::std::string* room_password_;
  ::proto::Player_t* playerinfo_;
  ::google::protobuf::int32 room_no_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GameMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GameMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_GameMsg_2eproto();
  friend void protobuf_ShutdownFile_GameMsg_2eproto();

  void InitAsDefaultInstance();
  static JoinRoom_req* default_instance_;
};
// -------------------------------------------------------------------

class JoinRoom_ack : public ::google::protobuf::MessageLite {
 public:
  JoinRoom_ack();
  virtual ~JoinRoom_ack();

  JoinRoom_ack(const JoinRoom_ack& from);

  inline JoinRoom_ack& operator=(const JoinRoom_ack& from) {
    CopyFrom(from);
    return *this;
  }

  static const JoinRoom_ack& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const JoinRoom_ack* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(JoinRoom_ack* other);

  // implements Message ----------------------------------------------

  JoinRoom_ack* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const JoinRoom_ack& from);
  void MergeFrom(const JoinRoom_ack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.ErrorCode_t error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::proto::ErrorCode_t error_code() const;
  inline void set_error_code(::proto::ErrorCode_t value);

  // optional int32 playerid = 2;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 2;
  inline ::google::protobuf::int32 playerid() const;
  inline void set_playerid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.JoinRoom_ack)
 private:
  inline void set_has_error_code();
  inline void clear_has_error_code();
  inline void set_has_playerid();
  inline void clear_has_playerid();

  int error_code_;
  ::google::protobuf::int32 playerid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GameMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GameMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_GameMsg_2eproto();
  friend void protobuf_ShutdownFile_GameMsg_2eproto();

  void InitAsDefaultInstance();
  static JoinRoom_ack* default_instance_;
};
// -------------------------------------------------------------------

class PlayerList_ntf : public ::google::protobuf::MessageLite {
 public:
  PlayerList_ntf();
  virtual ~PlayerList_ntf();

  PlayerList_ntf(const PlayerList_ntf& from);

  inline PlayerList_ntf& operator=(const PlayerList_ntf& from) {
    CopyFrom(from);
    return *this;
  }

  static const PlayerList_ntf& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlayerList_ntf* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlayerList_ntf* other);

  // implements Message ----------------------------------------------

  PlayerList_ntf* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlayerList_ntf& from);
  void MergeFrom(const PlayerList_ntf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.Player_t player_list = 1;
  inline int player_list_size() const;
  inline void clear_player_list();
  static const int kPlayerListFieldNumber = 1;
  inline const ::proto::Player_t& player_list(int index) const;
  inline ::proto::Player_t* mutable_player_list(int index);
  inline ::proto::Player_t* add_player_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::Player_t >&
      player_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::Player_t >*
      mutable_player_list();

  // @@protoc_insertion_point(class_scope:proto.PlayerList_ntf)
 private:

  ::google::protobuf::RepeatedPtrField< ::proto::Player_t > player_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GameMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GameMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_GameMsg_2eproto();
  friend void protobuf_ShutdownFile_GameMsg_2eproto();

  void InitAsDefaultInstance();
  static PlayerList_ntf* default_instance_;
};
// -------------------------------------------------------------------

class EnterGame_ntf : public ::google::protobuf::MessageLite {
 public:
  EnterGame_ntf();
  virtual ~EnterGame_ntf();

  EnterGame_ntf(const EnterGame_ntf& from);

  inline EnterGame_ntf& operator=(const EnterGame_ntf& from) {
    CopyFrom(from);
    return *this;
  }

  static const EnterGame_ntf& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EnterGame_ntf* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EnterGame_ntf* other);

  // implements Message ----------------------------------------------

  EnterGame_ntf* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EnterGame_ntf& from);
  void MergeFrom(const EnterGame_ntf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.Player_t player_list = 1;
  inline int player_list_size() const;
  inline void clear_player_list();
  static const int kPlayerListFieldNumber = 1;
  inline const ::proto::Player_t& player_list(int index) const;
  inline ::proto::Player_t* mutable_player_list(int index);
  inline ::proto::Player_t* add_player_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::Player_t >&
      player_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::Player_t >*
      mutable_player_list();

  // @@protoc_insertion_point(class_scope:proto.EnterGame_ntf)
 private:

  ::google::protobuf::RepeatedPtrField< ::proto::Player_t > player_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GameMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GameMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_GameMsg_2eproto();
  friend void protobuf_ShutdownFile_GameMsg_2eproto();

  void InitAsDefaultInstance();
  static EnterGame_ntf* default_instance_;
};
// -------------------------------------------------------------------

class EnterGameOk_req : public ::google::protobuf::MessageLite {
 public:
  EnterGameOk_req();
  virtual ~EnterGameOk_req();

  EnterGameOk_req(const EnterGameOk_req& from);

  inline EnterGameOk_req& operator=(const EnterGameOk_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const EnterGameOk_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EnterGameOk_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EnterGameOk_req* other);

  // implements Message ----------------------------------------------

  EnterGameOk_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EnterGameOk_req& from);
  void MergeFrom(const EnterGameOk_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 playerid = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 1;
  inline ::google::protobuf::int32 playerid() const;
  inline void set_playerid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.EnterGameOk_req)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();

  ::google::protobuf::int32 playerid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GameMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GameMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_GameMsg_2eproto();
  friend void protobuf_ShutdownFile_GameMsg_2eproto();

  void InitAsDefaultInstance();
  static EnterGameOk_req* default_instance_;
};
// -------------------------------------------------------------------

class StartRace_ntf : public ::google::protobuf::MessageLite {
 public:
  StartRace_ntf();
  virtual ~StartRace_ntf();

  StartRace_ntf(const StartRace_ntf& from);

  inline StartRace_ntf& operator=(const StartRace_ntf& from) {
    CopyFrom(from);
    return *this;
  }

  static const StartRace_ntf& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StartRace_ntf* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StartRace_ntf* other);

  // implements Message ----------------------------------------------

  StartRace_ntf* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StartRace_ntf& from);
  void MergeFrom(const StartRace_ntf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:proto.StartRace_ntf)
 private:


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GameMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GameMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_GameMsg_2eproto();
  friend void protobuf_ShutdownFile_GameMsg_2eproto();

  void InitAsDefaultInstance();
  static StartRace_ntf* default_instance_;
};
// -------------------------------------------------------------------

class LogicFrame_ntf : public ::google::protobuf::MessageLite {
 public:
  LogicFrame_ntf();
  virtual ~LogicFrame_ntf();

  LogicFrame_ntf(const LogicFrame_ntf& from);

  inline LogicFrame_ntf& operator=(const LogicFrame_ntf& from) {
    CopyFrom(from);
    return *this;
  }

  static const LogicFrame_ntf& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LogicFrame_ntf* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LogicFrame_ntf* other);

  // implements Message ----------------------------------------------

  LogicFrame_ntf* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LogicFrame_ntf& from);
  void MergeFrom(const LogicFrame_ntf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 frame_no = 1;
  inline bool has_frame_no() const;
  inline void clear_frame_no();
  static const int kFrameNoFieldNumber = 1;
  inline ::google::protobuf::int32 frame_no() const;
  inline void set_frame_no(::google::protobuf::int32 value);

  // repeated .proto.GameCommand_t command_list = 2;
  inline int command_list_size() const;
  inline void clear_command_list();
  static const int kCommandListFieldNumber = 2;
  inline const ::proto::GameCommand_t& command_list(int index) const;
  inline ::proto::GameCommand_t* mutable_command_list(int index);
  inline ::proto::GameCommand_t* add_command_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::GameCommand_t >&
      command_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::GameCommand_t >*
      mutable_command_list();

  // @@protoc_insertion_point(class_scope:proto.LogicFrame_ntf)
 private:
  inline void set_has_frame_no();
  inline void clear_has_frame_no();

  ::google::protobuf::RepeatedPtrField< ::proto::GameCommand_t > command_list_;
  ::google::protobuf::int32 frame_no_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GameMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GameMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_GameMsg_2eproto();
  friend void protobuf_ShutdownFile_GameMsg_2eproto();

  void InitAsDefaultInstance();
  static LogicFrame_ntf* default_instance_;
};
// ===================================================================


// ===================================================================

// User_t

// optional string userid = 1;
inline bool User_t::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void User_t::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void User_t::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void User_t::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& User_t::userid() const {
  return *userid_;
}
inline void User_t::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void User_t::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void User_t::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User_t::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* User_t::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void User_t::set_allocated_userid(::std::string* userid) {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    delete userid_;
  }
  if (userid) {
    set_has_userid();
    userid_ = userid;
  } else {
    clear_has_userid();
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string nickname = 2;
inline bool User_t::has_nickname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void User_t::set_has_nickname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void User_t::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void User_t::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& User_t::nickname() const {
  return *nickname_;
}
inline void User_t::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void User_t::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void User_t::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User_t::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* User_t::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void User_t::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Room_t

// optional int32 room_no = 1;
inline bool Room_t::has_room_no() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Room_t::set_has_room_no() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Room_t::clear_has_room_no() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Room_t::clear_room_no() {
  room_no_ = 0;
  clear_has_room_no();
}
inline ::google::protobuf::int32 Room_t::room_no() const {
  return room_no_;
}
inline void Room_t::set_room_no(::google::protobuf::int32 value) {
  set_has_room_no();
  room_no_ = value;
}

// optional string desp = 2;
inline bool Room_t::has_desp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Room_t::set_has_desp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Room_t::clear_has_desp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Room_t::clear_desp() {
  if (desp_ != &::google::protobuf::internal::kEmptyString) {
    desp_->clear();
  }
  clear_has_desp();
}
inline const ::std::string& Room_t::desp() const {
  return *desp_;
}
inline void Room_t::set_desp(const ::std::string& value) {
  set_has_desp();
  if (desp_ == &::google::protobuf::internal::kEmptyString) {
    desp_ = new ::std::string;
  }
  desp_->assign(value);
}
inline void Room_t::set_desp(const char* value) {
  set_has_desp();
  if (desp_ == &::google::protobuf::internal::kEmptyString) {
    desp_ = new ::std::string;
  }
  desp_->assign(value);
}
inline void Room_t::set_desp(const char* value, size_t size) {
  set_has_desp();
  if (desp_ == &::google::protobuf::internal::kEmptyString) {
    desp_ = new ::std::string;
  }
  desp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Room_t::mutable_desp() {
  set_has_desp();
  if (desp_ == &::google::protobuf::internal::kEmptyString) {
    desp_ = new ::std::string;
  }
  return desp_;
}
inline ::std::string* Room_t::release_desp() {
  clear_has_desp();
  if (desp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desp_;
    desp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Room_t::set_allocated_desp(::std::string* desp) {
  if (desp_ != &::google::protobuf::internal::kEmptyString) {
    delete desp_;
  }
  if (desp) {
    set_has_desp();
    desp_ = desp;
  } else {
    clear_has_desp();
    desp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Player_t

// optional int32 playerid = 1;
inline bool Player_t::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Player_t::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Player_t::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Player_t::clear_playerid() {
  playerid_ = 0;
  clear_has_playerid();
}
inline ::google::protobuf::int32 Player_t::playerid() const {
  return playerid_;
}
inline void Player_t::set_playerid(::google::protobuf::int32 value) {
  set_has_playerid();
  playerid_ = value;
}

// optional string userid = 2;
inline bool Player_t::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Player_t::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Player_t::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Player_t::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& Player_t::userid() const {
  return *userid_;
}
inline void Player_t::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void Player_t::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void Player_t::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Player_t::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* Player_t::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Player_t::set_allocated_userid(::std::string* userid) {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    delete userid_;
  }
  if (userid) {
    set_has_userid();
    userid_ = userid;
  } else {
    clear_has_userid();
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string car_name = 3;
inline bool Player_t::has_car_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Player_t::set_has_car_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Player_t::clear_has_car_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Player_t::clear_car_name() {
  if (car_name_ != &::google::protobuf::internal::kEmptyString) {
    car_name_->clear();
  }
  clear_has_car_name();
}
inline const ::std::string& Player_t::car_name() const {
  return *car_name_;
}
inline void Player_t::set_car_name(const ::std::string& value) {
  set_has_car_name();
  if (car_name_ == &::google::protobuf::internal::kEmptyString) {
    car_name_ = new ::std::string;
  }
  car_name_->assign(value);
}
inline void Player_t::set_car_name(const char* value) {
  set_has_car_name();
  if (car_name_ == &::google::protobuf::internal::kEmptyString) {
    car_name_ = new ::std::string;
  }
  car_name_->assign(value);
}
inline void Player_t::set_car_name(const char* value, size_t size) {
  set_has_car_name();
  if (car_name_ == &::google::protobuf::internal::kEmptyString) {
    car_name_ = new ::std::string;
  }
  car_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Player_t::mutable_car_name() {
  set_has_car_name();
  if (car_name_ == &::google::protobuf::internal::kEmptyString) {
    car_name_ = new ::std::string;
  }
  return car_name_;
}
inline ::std::string* Player_t::release_car_name() {
  clear_has_car_name();
  if (car_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = car_name_;
    car_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Player_t::set_allocated_car_name(::std::string* car_name) {
  if (car_name_ != &::google::protobuf::internal::kEmptyString) {
    delete car_name_;
  }
  if (car_name) {
    set_has_car_name();
    car_name_ = car_name;
  } else {
    clear_has_car_name();
    car_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 is_free = 4;
inline bool Player_t::has_is_free() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Player_t::set_has_is_free() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Player_t::clear_has_is_free() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Player_t::clear_is_free() {
  is_free_ = 0;
  clear_has_is_free();
}
inline ::google::protobuf::int32 Player_t::is_free() const {
  return is_free_;
}
inline void Player_t::set_is_free(::google::protobuf::int32 value) {
  set_has_is_free();
  is_free_ = value;
}

// optional int32 is_owned = 5;
inline bool Player_t::has_is_owned() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Player_t::set_has_is_owned() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Player_t::clear_has_is_owned() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Player_t::clear_is_owned() {
  is_owned_ = 0;
  clear_has_is_owned();
}
inline ::google::protobuf::int32 Player_t::is_owned() const {
  return is_owned_;
}
inline void Player_t::set_is_owned(::google::protobuf::int32 value) {
  set_has_is_owned();
  is_owned_ = value;
}

// optional int32 stage = 6;
inline bool Player_t::has_stage() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Player_t::set_has_stage() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Player_t::clear_has_stage() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Player_t::clear_stage() {
  stage_ = 0;
  clear_has_stage();
}
inline ::google::protobuf::int32 Player_t::stage() const {
  return stage_;
}
inline void Player_t::set_stage(::google::protobuf::int32 value) {
  set_has_stage();
  stage_ = value;
}

// optional string decal = 7;
inline bool Player_t::has_decal() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Player_t::set_has_decal() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Player_t::clear_has_decal() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Player_t::clear_decal() {
  if (decal_ != &::google::protobuf::internal::kEmptyString) {
    decal_->clear();
  }
  clear_has_decal();
}
inline const ::std::string& Player_t::decal() const {
  return *decal_;
}
inline void Player_t::set_decal(const ::std::string& value) {
  set_has_decal();
  if (decal_ == &::google::protobuf::internal::kEmptyString) {
    decal_ = new ::std::string;
  }
  decal_->assign(value);
}
inline void Player_t::set_decal(const char* value) {
  set_has_decal();
  if (decal_ == &::google::protobuf::internal::kEmptyString) {
    decal_ = new ::std::string;
  }
  decal_->assign(value);
}
inline void Player_t::set_decal(const char* value, size_t size) {
  set_has_decal();
  if (decal_ == &::google::protobuf::internal::kEmptyString) {
    decal_ = new ::std::string;
  }
  decal_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Player_t::mutable_decal() {
  set_has_decal();
  if (decal_ == &::google::protobuf::internal::kEmptyString) {
    decal_ = new ::std::string;
  }
  return decal_;
}
inline ::std::string* Player_t::release_decal() {
  clear_has_decal();
  if (decal_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = decal_;
    decal_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Player_t::set_allocated_decal(::std::string* decal) {
  if (decal_ != &::google::protobuf::internal::kEmptyString) {
    delete decal_;
  }
  if (decal) {
    set_has_decal();
    decal_ = decal;
  } else {
    clear_has_decal();
    decal_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string decal_color = 8;
inline bool Player_t::has_decal_color() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Player_t::set_has_decal_color() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Player_t::clear_has_decal_color() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Player_t::clear_decal_color() {
  if (decal_color_ != &::google::protobuf::internal::kEmptyString) {
    decal_color_->clear();
  }
  clear_has_decal_color();
}
inline const ::std::string& Player_t::decal_color() const {
  return *decal_color_;
}
inline void Player_t::set_decal_color(const ::std::string& value) {
  set_has_decal_color();
  if (decal_color_ == &::google::protobuf::internal::kEmptyString) {
    decal_color_ = new ::std::string;
  }
  decal_color_->assign(value);
}
inline void Player_t::set_decal_color(const char* value) {
  set_has_decal_color();
  if (decal_color_ == &::google::protobuf::internal::kEmptyString) {
    decal_color_ = new ::std::string;
  }
  decal_color_->assign(value);
}
inline void Player_t::set_decal_color(const char* value, size_t size) {
  set_has_decal_color();
  if (decal_color_ == &::google::protobuf::internal::kEmptyString) {
    decal_color_ = new ::std::string;
  }
  decal_color_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Player_t::mutable_decal_color() {
  set_has_decal_color();
  if (decal_color_ == &::google::protobuf::internal::kEmptyString) {
    decal_color_ = new ::std::string;
  }
  return decal_color_;
}
inline ::std::string* Player_t::release_decal_color() {
  clear_has_decal_color();
  if (decal_color_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = decal_color_;
    decal_color_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Player_t::set_allocated_decal_color(::std::string* decal_color) {
  if (decal_color_ != &::google::protobuf::internal::kEmptyString) {
    delete decal_color_;
  }
  if (decal_color) {
    set_has_decal_color();
    decal_color_ = decal_color;
  } else {
    clear_has_decal_color();
    decal_color_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string driver_name = 9;
inline bool Player_t::has_driver_name() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Player_t::set_has_driver_name() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Player_t::clear_has_driver_name() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Player_t::clear_driver_name() {
  if (driver_name_ != &::google::protobuf::internal::kEmptyString) {
    driver_name_->clear();
  }
  clear_has_driver_name();
}
inline const ::std::string& Player_t::driver_name() const {
  return *driver_name_;
}
inline void Player_t::set_driver_name(const ::std::string& value) {
  set_has_driver_name();
  if (driver_name_ == &::google::protobuf::internal::kEmptyString) {
    driver_name_ = new ::std::string;
  }
  driver_name_->assign(value);
}
inline void Player_t::set_driver_name(const char* value) {
  set_has_driver_name();
  if (driver_name_ == &::google::protobuf::internal::kEmptyString) {
    driver_name_ = new ::std::string;
  }
  driver_name_->assign(value);
}
inline void Player_t::set_driver_name(const char* value, size_t size) {
  set_has_driver_name();
  if (driver_name_ == &::google::protobuf::internal::kEmptyString) {
    driver_name_ = new ::std::string;
  }
  driver_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Player_t::mutable_driver_name() {
  set_has_driver_name();
  if (driver_name_ == &::google::protobuf::internal::kEmptyString) {
    driver_name_ = new ::std::string;
  }
  return driver_name_;
}
inline ::std::string* Player_t::release_driver_name() {
  clear_has_driver_name();
  if (driver_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = driver_name_;
    driver_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Player_t::set_allocated_driver_name(::std::string* driver_name) {
  if (driver_name_ != &::google::protobuf::internal::kEmptyString) {
    delete driver_name_;
  }
  if (driver_name) {
    set_has_driver_name();
    driver_name_ = driver_name;
  } else {
    clear_has_driver_name();
    driver_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string driver_type = 10;
inline bool Player_t::has_driver_type() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Player_t::set_has_driver_type() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Player_t::clear_has_driver_type() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Player_t::clear_driver_type() {
  if (driver_type_ != &::google::protobuf::internal::kEmptyString) {
    driver_type_->clear();
  }
  clear_has_driver_type();
}
inline const ::std::string& Player_t::driver_type() const {
  return *driver_type_;
}
inline void Player_t::set_driver_type(const ::std::string& value) {
  set_has_driver_type();
  if (driver_type_ == &::google::protobuf::internal::kEmptyString) {
    driver_type_ = new ::std::string;
  }
  driver_type_->assign(value);
}
inline void Player_t::set_driver_type(const char* value) {
  set_has_driver_type();
  if (driver_type_ == &::google::protobuf::internal::kEmptyString) {
    driver_type_ = new ::std::string;
  }
  driver_type_->assign(value);
}
inline void Player_t::set_driver_type(const char* value, size_t size) {
  set_has_driver_type();
  if (driver_type_ == &::google::protobuf::internal::kEmptyString) {
    driver_type_ = new ::std::string;
  }
  driver_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Player_t::mutable_driver_type() {
  set_has_driver_type();
  if (driver_type_ == &::google::protobuf::internal::kEmptyString) {
    driver_type_ = new ::std::string;
  }
  return driver_type_;
}
inline ::std::string* Player_t::release_driver_type() {
  clear_has_driver_type();
  if (driver_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = driver_type_;
    driver_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Player_t::set_allocated_driver_type(::std::string* driver_type) {
  if (driver_type_ != &::google::protobuf::internal::kEmptyString) {
    delete driver_type_;
  }
  if (driver_type) {
    set_has_driver_type();
    driver_type_ = driver_type;
  } else {
    clear_has_driver_type();
    driver_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 accel = 11;
inline bool Player_t::has_accel() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Player_t::set_has_accel() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Player_t::clear_has_accel() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Player_t::clear_accel() {
  accel_ = 0;
  clear_has_accel();
}
inline ::google::protobuf::int32 Player_t::accel() const {
  return accel_;
}
inline void Player_t::set_accel(::google::protobuf::int32 value) {
  set_has_accel();
  accel_ = value;
}

// optional int32 speed = 12;
inline bool Player_t::has_speed() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Player_t::set_has_speed() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Player_t::clear_has_speed() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Player_t::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline ::google::protobuf::int32 Player_t::speed() const {
  return speed_;
}
inline void Player_t::set_speed(::google::protobuf::int32 value) {
  set_has_speed();
  speed_ = value;
}

// optional int32 handling = 13;
inline bool Player_t::has_handling() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Player_t::set_has_handling() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Player_t::clear_has_handling() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Player_t::clear_handling() {
  handling_ = 0;
  clear_has_handling();
}
inline ::google::protobuf::int32 Player_t::handling() const {
  return handling_;
}
inline void Player_t::set_handling(::google::protobuf::int32 value) {
  set_has_handling();
  handling_ = value;
}

// optional int32 tough = 14;
inline bool Player_t::has_tough() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Player_t::set_has_tough() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Player_t::clear_has_tough() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Player_t::clear_tough() {
  tough_ = 0;
  clear_has_tough();
}
inline ::google::protobuf::int32 Player_t::tough() const {
  return tough_;
}
inline void Player_t::set_tough(::google::protobuf::int32 value) {
  set_has_tough();
  tough_ = value;
}

// optional int32 is_gold = 15;
inline bool Player_t::has_is_gold() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Player_t::set_has_is_gold() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Player_t::clear_has_is_gold() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Player_t::clear_is_gold() {
  is_gold_ = 0;
  clear_has_is_gold();
}
inline ::google::protobuf::int32 Player_t::is_gold() const {
  return is_gold_;
}
inline void Player_t::set_is_gold(::google::protobuf::int32 value) {
  set_has_is_gold();
  is_gold_ = value;
}

// optional int32 min_stage = 16;
inline bool Player_t::has_min_stage() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Player_t::set_has_min_stage() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Player_t::clear_has_min_stage() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Player_t::clear_min_stage() {
  min_stage_ = 0;
  clear_has_min_stage();
}
inline ::google::protobuf::int32 Player_t::min_stage() const {
  return min_stage_;
}
inline void Player_t::set_min_stage(::google::protobuf::int32 value) {
  set_has_min_stage();
  min_stage_ = value;
}

// optional int32 max_stage = 17;
inline bool Player_t::has_max_stage() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Player_t::set_has_max_stage() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Player_t::clear_has_max_stage() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Player_t::clear_max_stage() {
  max_stage_ = 0;
  clear_has_max_stage();
}
inline ::google::protobuf::int32 Player_t::max_stage() const {
  return max_stage_;
}
inline void Player_t::set_max_stage(::google::protobuf::int32 value) {
  set_has_max_stage();
  max_stage_ = value;
}

// optional string paint_color = 18;
inline bool Player_t::has_paint_color() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Player_t::set_has_paint_color() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Player_t::clear_has_paint_color() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Player_t::clear_paint_color() {
  if (paint_color_ != &::google::protobuf::internal::kEmptyString) {
    paint_color_->clear();
  }
  clear_has_paint_color();
}
inline const ::std::string& Player_t::paint_color() const {
  return *paint_color_;
}
inline void Player_t::set_paint_color(const ::std::string& value) {
  set_has_paint_color();
  if (paint_color_ == &::google::protobuf::internal::kEmptyString) {
    paint_color_ = new ::std::string;
  }
  paint_color_->assign(value);
}
inline void Player_t::set_paint_color(const char* value) {
  set_has_paint_color();
  if (paint_color_ == &::google::protobuf::internal::kEmptyString) {
    paint_color_ = new ::std::string;
  }
  paint_color_->assign(value);
}
inline void Player_t::set_paint_color(const char* value, size_t size) {
  set_has_paint_color();
  if (paint_color_ == &::google::protobuf::internal::kEmptyString) {
    paint_color_ = new ::std::string;
  }
  paint_color_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Player_t::mutable_paint_color() {
  set_has_paint_color();
  if (paint_color_ == &::google::protobuf::internal::kEmptyString) {
    paint_color_ = new ::std::string;
  }
  return paint_color_;
}
inline ::std::string* Player_t::release_paint_color() {
  clear_has_paint_color();
  if (paint_color_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = paint_color_;
    paint_color_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Player_t::set_allocated_paint_color(::std::string* paint_color) {
  if (paint_color_ != &::google::protobuf::internal::kEmptyString) {
    delete paint_color_;
  }
  if (paint_color) {
    set_has_paint_color();
    paint_color_ = paint_color;
  } else {
    clear_has_paint_color();
    paint_color_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GameCommand_t

// optional int32 command_type = 1;
inline bool GameCommand_t::has_command_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameCommand_t::set_has_command_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameCommand_t::clear_has_command_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameCommand_t::clear_command_type() {
  command_type_ = 0;
  clear_has_command_type();
}
inline ::google::protobuf::int32 GameCommand_t::command_type() const {
  return command_type_;
}
inline void GameCommand_t::set_command_type(::google::protobuf::int32 value) {
  set_has_command_type();
  command_type_ = value;
}

// optional int32 playerid = 2;
inline bool GameCommand_t::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameCommand_t::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameCommand_t::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameCommand_t::clear_playerid() {
  playerid_ = 0;
  clear_has_playerid();
}
inline ::google::protobuf::int32 GameCommand_t::playerid() const {
  return playerid_;
}
inline void GameCommand_t::set_playerid(::google::protobuf::int32 value) {
  set_has_playerid();
  playerid_ = value;
}

// optional int32 intvar1 = 3;
inline bool GameCommand_t::has_intvar1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameCommand_t::set_has_intvar1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameCommand_t::clear_has_intvar1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameCommand_t::clear_intvar1() {
  intvar1_ = 0;
  clear_has_intvar1();
}
inline ::google::protobuf::int32 GameCommand_t::intvar1() const {
  return intvar1_;
}
inline void GameCommand_t::set_intvar1(::google::protobuf::int32 value) {
  set_has_intvar1();
  intvar1_ = value;
}

// optional int32 intvar2 = 4;
inline bool GameCommand_t::has_intvar2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameCommand_t::set_has_intvar2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameCommand_t::clear_has_intvar2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameCommand_t::clear_intvar2() {
  intvar2_ = 0;
  clear_has_intvar2();
}
inline ::google::protobuf::int32 GameCommand_t::intvar2() const {
  return intvar2_;
}
inline void GameCommand_t::set_intvar2(::google::protobuf::int32 value) {
  set_has_intvar2();
  intvar2_ = value;
}

// optional int32 intvar3 = 5;
inline bool GameCommand_t::has_intvar3() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameCommand_t::set_has_intvar3() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameCommand_t::clear_has_intvar3() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameCommand_t::clear_intvar3() {
  intvar3_ = 0;
  clear_has_intvar3();
}
inline ::google::protobuf::int32 GameCommand_t::intvar3() const {
  return intvar3_;
}
inline void GameCommand_t::set_intvar3(::google::protobuf::int32 value) {
  set_has_intvar3();
  intvar3_ = value;
}

// optional string strvar1 = 6;
inline bool GameCommand_t::has_strvar1() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GameCommand_t::set_has_strvar1() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GameCommand_t::clear_has_strvar1() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GameCommand_t::clear_strvar1() {
  if (strvar1_ != &::google::protobuf::internal::kEmptyString) {
    strvar1_->clear();
  }
  clear_has_strvar1();
}
inline const ::std::string& GameCommand_t::strvar1() const {
  return *strvar1_;
}
inline void GameCommand_t::set_strvar1(const ::std::string& value) {
  set_has_strvar1();
  if (strvar1_ == &::google::protobuf::internal::kEmptyString) {
    strvar1_ = new ::std::string;
  }
  strvar1_->assign(value);
}
inline void GameCommand_t::set_strvar1(const char* value) {
  set_has_strvar1();
  if (strvar1_ == &::google::protobuf::internal::kEmptyString) {
    strvar1_ = new ::std::string;
  }
  strvar1_->assign(value);
}
inline void GameCommand_t::set_strvar1(const char* value, size_t size) {
  set_has_strvar1();
  if (strvar1_ == &::google::protobuf::internal::kEmptyString) {
    strvar1_ = new ::std::string;
  }
  strvar1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameCommand_t::mutable_strvar1() {
  set_has_strvar1();
  if (strvar1_ == &::google::protobuf::internal::kEmptyString) {
    strvar1_ = new ::std::string;
  }
  return strvar1_;
}
inline ::std::string* GameCommand_t::release_strvar1() {
  clear_has_strvar1();
  if (strvar1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strvar1_;
    strvar1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameCommand_t::set_allocated_strvar1(::std::string* strvar1) {
  if (strvar1_ != &::google::protobuf::internal::kEmptyString) {
    delete strvar1_;
  }
  if (strvar1) {
    set_has_strvar1();
    strvar1_ = strvar1;
  } else {
    clear_has_strvar1();
    strvar1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string strvar2 = 7;
inline bool GameCommand_t::has_strvar2() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GameCommand_t::set_has_strvar2() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GameCommand_t::clear_has_strvar2() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GameCommand_t::clear_strvar2() {
  if (strvar2_ != &::google::protobuf::internal::kEmptyString) {
    strvar2_->clear();
  }
  clear_has_strvar2();
}
inline const ::std::string& GameCommand_t::strvar2() const {
  return *strvar2_;
}
inline void GameCommand_t::set_strvar2(const ::std::string& value) {
  set_has_strvar2();
  if (strvar2_ == &::google::protobuf::internal::kEmptyString) {
    strvar2_ = new ::std::string;
  }
  strvar2_->assign(value);
}
inline void GameCommand_t::set_strvar2(const char* value) {
  set_has_strvar2();
  if (strvar2_ == &::google::protobuf::internal::kEmptyString) {
    strvar2_ = new ::std::string;
  }
  strvar2_->assign(value);
}
inline void GameCommand_t::set_strvar2(const char* value, size_t size) {
  set_has_strvar2();
  if (strvar2_ == &::google::protobuf::internal::kEmptyString) {
    strvar2_ = new ::std::string;
  }
  strvar2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameCommand_t::mutable_strvar2() {
  set_has_strvar2();
  if (strvar2_ == &::google::protobuf::internal::kEmptyString) {
    strvar2_ = new ::std::string;
  }
  return strvar2_;
}
inline ::std::string* GameCommand_t::release_strvar2() {
  clear_has_strvar2();
  if (strvar2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strvar2_;
    strvar2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameCommand_t::set_allocated_strvar2(::std::string* strvar2) {
  if (strvar2_ != &::google::protobuf::internal::kEmptyString) {
    delete strvar2_;
  }
  if (strvar2) {
    set_has_strvar2();
    strvar2_ = strvar2;
  } else {
    clear_has_strvar2();
    strvar2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string strvar3 = 8;
inline bool GameCommand_t::has_strvar3() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GameCommand_t::set_has_strvar3() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GameCommand_t::clear_has_strvar3() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GameCommand_t::clear_strvar3() {
  if (strvar3_ != &::google::protobuf::internal::kEmptyString) {
    strvar3_->clear();
  }
  clear_has_strvar3();
}
inline const ::std::string& GameCommand_t::strvar3() const {
  return *strvar3_;
}
inline void GameCommand_t::set_strvar3(const ::std::string& value) {
  set_has_strvar3();
  if (strvar3_ == &::google::protobuf::internal::kEmptyString) {
    strvar3_ = new ::std::string;
  }
  strvar3_->assign(value);
}
inline void GameCommand_t::set_strvar3(const char* value) {
  set_has_strvar3();
  if (strvar3_ == &::google::protobuf::internal::kEmptyString) {
    strvar3_ = new ::std::string;
  }
  strvar3_->assign(value);
}
inline void GameCommand_t::set_strvar3(const char* value, size_t size) {
  set_has_strvar3();
  if (strvar3_ == &::google::protobuf::internal::kEmptyString) {
    strvar3_ = new ::std::string;
  }
  strvar3_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameCommand_t::mutable_strvar3() {
  set_has_strvar3();
  if (strvar3_ == &::google::protobuf::internal::kEmptyString) {
    strvar3_ = new ::std::string;
  }
  return strvar3_;
}
inline ::std::string* GameCommand_t::release_strvar3() {
  clear_has_strvar3();
  if (strvar3_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strvar3_;
    strvar3_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameCommand_t::set_allocated_strvar3(::std::string* strvar3) {
  if (strvar3_ != &::google::protobuf::internal::kEmptyString) {
    delete strvar3_;
  }
  if (strvar3) {
    set_has_strvar3();
    strvar3_ = strvar3;
  } else {
    clear_has_strvar3();
    strvar3_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Login_req

// optional .proto.User_t userinfo = 1;
inline bool Login_req::has_userinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Login_req::set_has_userinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Login_req::clear_has_userinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Login_req::clear_userinfo() {
  if (userinfo_ != NULL) userinfo_->::proto::User_t::Clear();
  clear_has_userinfo();
}
inline const ::proto::User_t& Login_req::userinfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return userinfo_ != NULL ? *userinfo_ : *default_instance().userinfo_;
#else
  return userinfo_ != NULL ? *userinfo_ : *default_instance_->userinfo_;
#endif
}
inline ::proto::User_t* Login_req::mutable_userinfo() {
  set_has_userinfo();
  if (userinfo_ == NULL) userinfo_ = new ::proto::User_t;
  return userinfo_;
}
inline ::proto::User_t* Login_req::release_userinfo() {
  clear_has_userinfo();
  ::proto::User_t* temp = userinfo_;
  userinfo_ = NULL;
  return temp;
}
inline void Login_req::set_allocated_userinfo(::proto::User_t* userinfo) {
  delete userinfo_;
  userinfo_ = userinfo;
  if (userinfo) {
    set_has_userinfo();
  } else {
    clear_has_userinfo();
  }
}

// -------------------------------------------------------------------

// Login_ack

// optional .proto.ErrorCode_t error_code = 1;
inline bool Login_ack::has_error_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Login_ack::set_has_error_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Login_ack::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Login_ack::clear_error_code() {
  error_code_ = 0;
  clear_has_error_code();
}
inline ::proto::ErrorCode_t Login_ack::error_code() const {
  return static_cast< ::proto::ErrorCode_t >(error_code_);
}
inline void Login_ack::set_error_code(::proto::ErrorCode_t value) {
  assert(::proto::ErrorCode_t_IsValid(value));
  set_has_error_code();
  error_code_ = value;
}

// -------------------------------------------------------------------

// ListRoom_req

// optional int32 offset = 1;
inline bool ListRoom_req::has_offset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ListRoom_req::set_has_offset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ListRoom_req::clear_has_offset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ListRoom_req::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline ::google::protobuf::int32 ListRoom_req::offset() const {
  return offset_;
}
inline void ListRoom_req::set_offset(::google::protobuf::int32 value) {
  set_has_offset();
  offset_ = value;
}

// -------------------------------------------------------------------

// ListRoom_ack

// optional .proto.ErrorCode_t error_code = 1;
inline bool ListRoom_ack::has_error_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ListRoom_ack::set_has_error_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ListRoom_ack::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ListRoom_ack::clear_error_code() {
  error_code_ = 0;
  clear_has_error_code();
}
inline ::proto::ErrorCode_t ListRoom_ack::error_code() const {
  return static_cast< ::proto::ErrorCode_t >(error_code_);
}
inline void ListRoom_ack::set_error_code(::proto::ErrorCode_t value) {
  assert(::proto::ErrorCode_t_IsValid(value));
  set_has_error_code();
  error_code_ = value;
}

// repeated .proto.Room_t room_list = 2;
inline int ListRoom_ack::room_list_size() const {
  return room_list_.size();
}
inline void ListRoom_ack::clear_room_list() {
  room_list_.Clear();
}
inline const ::proto::Room_t& ListRoom_ack::room_list(int index) const {
  return room_list_.Get(index);
}
inline ::proto::Room_t* ListRoom_ack::mutable_room_list(int index) {
  return room_list_.Mutable(index);
}
inline ::proto::Room_t* ListRoom_ack::add_room_list() {
  return room_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::Room_t >&
ListRoom_ack::room_list() const {
  return room_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::Room_t >*
ListRoom_ack::mutable_room_list() {
  return &room_list_;
}

// -------------------------------------------------------------------

// CreateRoom_req

// optional string userid = 1;
inline bool CreateRoom_req::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateRoom_req::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateRoom_req::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateRoom_req::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& CreateRoom_req::userid() const {
  return *userid_;
}
inline void CreateRoom_req::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void CreateRoom_req::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void CreateRoom_req::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateRoom_req::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* CreateRoom_req::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateRoom_req::set_allocated_userid(::std::string* userid) {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    delete userid_;
  }
  if (userid) {
    set_has_userid();
    userid_ = userid;
  } else {
    clear_has_userid();
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string room_password = 2;
inline bool CreateRoom_req::has_room_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateRoom_req::set_has_room_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateRoom_req::clear_has_room_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateRoom_req::clear_room_password() {
  if (room_password_ != &::google::protobuf::internal::kEmptyString) {
    room_password_->clear();
  }
  clear_has_room_password();
}
inline const ::std::string& CreateRoom_req::room_password() const {
  return *room_password_;
}
inline void CreateRoom_req::set_room_password(const ::std::string& value) {
  set_has_room_password();
  if (room_password_ == &::google::protobuf::internal::kEmptyString) {
    room_password_ = new ::std::string;
  }
  room_password_->assign(value);
}
inline void CreateRoom_req::set_room_password(const char* value) {
  set_has_room_password();
  if (room_password_ == &::google::protobuf::internal::kEmptyString) {
    room_password_ = new ::std::string;
  }
  room_password_->assign(value);
}
inline void CreateRoom_req::set_room_password(const char* value, size_t size) {
  set_has_room_password();
  if (room_password_ == &::google::protobuf::internal::kEmptyString) {
    room_password_ = new ::std::string;
  }
  room_password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateRoom_req::mutable_room_password() {
  set_has_room_password();
  if (room_password_ == &::google::protobuf::internal::kEmptyString) {
    room_password_ = new ::std::string;
  }
  return room_password_;
}
inline ::std::string* CreateRoom_req::release_room_password() {
  clear_has_room_password();
  if (room_password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = room_password_;
    room_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateRoom_req::set_allocated_room_password(::std::string* room_password) {
  if (room_password_ != &::google::protobuf::internal::kEmptyString) {
    delete room_password_;
  }
  if (room_password) {
    set_has_room_password();
    room_password_ = room_password;
  } else {
    clear_has_room_password();
    room_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CreateRoom_ack

// optional .proto.ErrorCode_t error_code = 1;
inline bool CreateRoom_ack::has_error_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateRoom_ack::set_has_error_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateRoom_ack::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateRoom_ack::clear_error_code() {
  error_code_ = 0;
  clear_has_error_code();
}
inline ::proto::ErrorCode_t CreateRoom_ack::error_code() const {
  return static_cast< ::proto::ErrorCode_t >(error_code_);
}
inline void CreateRoom_ack::set_error_code(::proto::ErrorCode_t value) {
  assert(::proto::ErrorCode_t_IsValid(value));
  set_has_error_code();
  error_code_ = value;
}

// -------------------------------------------------------------------

// JoinRoom_req

// optional string userid = 1;
inline bool JoinRoom_req::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JoinRoom_req::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JoinRoom_req::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JoinRoom_req::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& JoinRoom_req::userid() const {
  return *userid_;
}
inline void JoinRoom_req::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void JoinRoom_req::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void JoinRoom_req::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JoinRoom_req::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* JoinRoom_req::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void JoinRoom_req::set_allocated_userid(::std::string* userid) {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    delete userid_;
  }
  if (userid) {
    set_has_userid();
    userid_ = userid;
  } else {
    clear_has_userid();
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string room_password = 2;
inline bool JoinRoom_req::has_room_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JoinRoom_req::set_has_room_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JoinRoom_req::clear_has_room_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JoinRoom_req::clear_room_password() {
  if (room_password_ != &::google::protobuf::internal::kEmptyString) {
    room_password_->clear();
  }
  clear_has_room_password();
}
inline const ::std::string& JoinRoom_req::room_password() const {
  return *room_password_;
}
inline void JoinRoom_req::set_room_password(const ::std::string& value) {
  set_has_room_password();
  if (room_password_ == &::google::protobuf::internal::kEmptyString) {
    room_password_ = new ::std::string;
  }
  room_password_->assign(value);
}
inline void JoinRoom_req::set_room_password(const char* value) {
  set_has_room_password();
  if (room_password_ == &::google::protobuf::internal::kEmptyString) {
    room_password_ = new ::std::string;
  }
  room_password_->assign(value);
}
inline void JoinRoom_req::set_room_password(const char* value, size_t size) {
  set_has_room_password();
  if (room_password_ == &::google::protobuf::internal::kEmptyString) {
    room_password_ = new ::std::string;
  }
  room_password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JoinRoom_req::mutable_room_password() {
  set_has_room_password();
  if (room_password_ == &::google::protobuf::internal::kEmptyString) {
    room_password_ = new ::std::string;
  }
  return room_password_;
}
inline ::std::string* JoinRoom_req::release_room_password() {
  clear_has_room_password();
  if (room_password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = room_password_;
    room_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void JoinRoom_req::set_allocated_room_password(::std::string* room_password) {
  if (room_password_ != &::google::protobuf::internal::kEmptyString) {
    delete room_password_;
  }
  if (room_password) {
    set_has_room_password();
    room_password_ = room_password;
  } else {
    clear_has_room_password();
    room_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 room_no = 3;
inline bool JoinRoom_req::has_room_no() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JoinRoom_req::set_has_room_no() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JoinRoom_req::clear_has_room_no() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JoinRoom_req::clear_room_no() {
  room_no_ = 0;
  clear_has_room_no();
}
inline ::google::protobuf::int32 JoinRoom_req::room_no() const {
  return room_no_;
}
inline void JoinRoom_req::set_room_no(::google::protobuf::int32 value) {
  set_has_room_no();
  room_no_ = value;
}

// optional .proto.Player_t playerinfo = 4;
inline bool JoinRoom_req::has_playerinfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void JoinRoom_req::set_has_playerinfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void JoinRoom_req::clear_has_playerinfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void JoinRoom_req::clear_playerinfo() {
  if (playerinfo_ != NULL) playerinfo_->::proto::Player_t::Clear();
  clear_has_playerinfo();
}
inline const ::proto::Player_t& JoinRoom_req::playerinfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return playerinfo_ != NULL ? *playerinfo_ : *default_instance().playerinfo_;
#else
  return playerinfo_ != NULL ? *playerinfo_ : *default_instance_->playerinfo_;
#endif
}
inline ::proto::Player_t* JoinRoom_req::mutable_playerinfo() {
  set_has_playerinfo();
  if (playerinfo_ == NULL) playerinfo_ = new ::proto::Player_t;
  return playerinfo_;
}
inline ::proto::Player_t* JoinRoom_req::release_playerinfo() {
  clear_has_playerinfo();
  ::proto::Player_t* temp = playerinfo_;
  playerinfo_ = NULL;
  return temp;
}
inline void JoinRoom_req::set_allocated_playerinfo(::proto::Player_t* playerinfo) {
  delete playerinfo_;
  playerinfo_ = playerinfo;
  if (playerinfo) {
    set_has_playerinfo();
  } else {
    clear_has_playerinfo();
  }
}

// -------------------------------------------------------------------

// JoinRoom_ack

// optional .proto.ErrorCode_t error_code = 1;
inline bool JoinRoom_ack::has_error_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JoinRoom_ack::set_has_error_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JoinRoom_ack::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JoinRoom_ack::clear_error_code() {
  error_code_ = 0;
  clear_has_error_code();
}
inline ::proto::ErrorCode_t JoinRoom_ack::error_code() const {
  return static_cast< ::proto::ErrorCode_t >(error_code_);
}
inline void JoinRoom_ack::set_error_code(::proto::ErrorCode_t value) {
  assert(::proto::ErrorCode_t_IsValid(value));
  set_has_error_code();
  error_code_ = value;
}

// optional int32 playerid = 2;
inline bool JoinRoom_ack::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JoinRoom_ack::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JoinRoom_ack::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JoinRoom_ack::clear_playerid() {
  playerid_ = 0;
  clear_has_playerid();
}
inline ::google::protobuf::int32 JoinRoom_ack::playerid() const {
  return playerid_;
}
inline void JoinRoom_ack::set_playerid(::google::protobuf::int32 value) {
  set_has_playerid();
  playerid_ = value;
}

// -------------------------------------------------------------------

// PlayerList_ntf

// repeated .proto.Player_t player_list = 1;
inline int PlayerList_ntf::player_list_size() const {
  return player_list_.size();
}
inline void PlayerList_ntf::clear_player_list() {
  player_list_.Clear();
}
inline const ::proto::Player_t& PlayerList_ntf::player_list(int index) const {
  return player_list_.Get(index);
}
inline ::proto::Player_t* PlayerList_ntf::mutable_player_list(int index) {
  return player_list_.Mutable(index);
}
inline ::proto::Player_t* PlayerList_ntf::add_player_list() {
  return player_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::Player_t >&
PlayerList_ntf::player_list() const {
  return player_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::Player_t >*
PlayerList_ntf::mutable_player_list() {
  return &player_list_;
}

// -------------------------------------------------------------------

// EnterGame_ntf

// repeated .proto.Player_t player_list = 1;
inline int EnterGame_ntf::player_list_size() const {
  return player_list_.size();
}
inline void EnterGame_ntf::clear_player_list() {
  player_list_.Clear();
}
inline const ::proto::Player_t& EnterGame_ntf::player_list(int index) const {
  return player_list_.Get(index);
}
inline ::proto::Player_t* EnterGame_ntf::mutable_player_list(int index) {
  return player_list_.Mutable(index);
}
inline ::proto::Player_t* EnterGame_ntf::add_player_list() {
  return player_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::Player_t >&
EnterGame_ntf::player_list() const {
  return player_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::Player_t >*
EnterGame_ntf::mutable_player_list() {
  return &player_list_;
}

// -------------------------------------------------------------------

// EnterGameOk_req

// optional int32 playerid = 1;
inline bool EnterGameOk_req::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterGameOk_req::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterGameOk_req::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterGameOk_req::clear_playerid() {
  playerid_ = 0;
  clear_has_playerid();
}
inline ::google::protobuf::int32 EnterGameOk_req::playerid() const {
  return playerid_;
}
inline void EnterGameOk_req::set_playerid(::google::protobuf::int32 value) {
  set_has_playerid();
  playerid_ = value;
}

// -------------------------------------------------------------------

// StartRace_ntf

// -------------------------------------------------------------------

// LogicFrame_ntf

// optional int32 frame_no = 1;
inline bool LogicFrame_ntf::has_frame_no() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogicFrame_ntf::set_has_frame_no() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogicFrame_ntf::clear_has_frame_no() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogicFrame_ntf::clear_frame_no() {
  frame_no_ = 0;
  clear_has_frame_no();
}
inline ::google::protobuf::int32 LogicFrame_ntf::frame_no() const {
  return frame_no_;
}
inline void LogicFrame_ntf::set_frame_no(::google::protobuf::int32 value) {
  set_has_frame_no();
  frame_no_ = value;
}

// repeated .proto.GameCommand_t command_list = 2;
inline int LogicFrame_ntf::command_list_size() const {
  return command_list_.size();
}
inline void LogicFrame_ntf::clear_command_list() {
  command_list_.Clear();
}
inline const ::proto::GameCommand_t& LogicFrame_ntf::command_list(int index) const {
  return command_list_.Get(index);
}
inline ::proto::GameCommand_t* LogicFrame_ntf::mutable_command_list(int index) {
  return command_list_.Mutable(index);
}
inline ::proto::GameCommand_t* LogicFrame_ntf::add_command_list() {
  return command_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::GameCommand_t >&
LogicFrame_ntf::command_list() const {
  return command_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::GameCommand_t >*
LogicFrame_ntf::mutable_command_list() {
  return &command_list_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_GameMsg_2eproto__INCLUDED
